<?xml version="1.0" encoding="UTF-8"?>
<config_list>
  <tool_config version="1.0.71" mwdt_version="O-2018.06" />
  <configuration name="BCRs" filename="bcr_contents.txt">
    <string><![CDATA[
	0x4	0x54		IDENTITY
	0x5e	0xf0000002	AUX_VOLATILE
	0x60	0x2		BCR_VER
	0x68	0x10		VECBASE_AC_BUILD
	0x6d	0x803		MPU_BUILD
	0x6e	0xc902		RF_BUILD
	0x6f	0x5e21a4a	MMU_BUILD
	0x72	0x10227105	D_CACHE_BUILD
	0x75	0x10704		TIMER_BUILD
	0x76	0x205		AP_BUILD
	0x77	0x237204	I_CACHE_BUILD
	0x7a	0x7622		DSP_BUILD
	0x7b	0x23206		MULTIPLY_BUILD
	0x7c	0x3		SWAP_BUILD
	0x7d	0x3		NORM_BUILD
	0x7e	0x2		MINMAX_BUILD
	0x7f	0x303		BARREL_BUILD
	0xc0	0x3e55b05	BPU_BUILD
	0xc1	0x23e47402	ISA_CONFIG
	0xc5	0x2		STACK_REGION_BUILD
	0xc8	0xf0f01		FPU_BUILD
	0xcc	0x42403		AGU_BUILD
	0xce	0x103		SLC_BUILD
	0xcf	0x1080404	CLUSTER_BUILD
	0xd0	0x2847e02	CONNECT_SYSTEM_BUILD
	0xd1	0x101		CONNECT_SEMA_BUILD
	0xd2	0x203		CONNECT_MESSAGE_BUILD
	0xd3	0x3		CONNECT_PMU_BUILD
	0xd5	0x402		CONNECT_IDU_BUILD
	0xd6	0x3		CONNECT_GFRC_BUILD
	0xe0	0x2		CONNECT_ICI_BUILD
	0xe1	0x2		CONNECT_ICD_BUILD
	0xe3	0x1		CONNECT_PDM_BUILD
	0xe5	0x1c302		CSM_BUILD
	0xe6	0x256301	DMA_BUILD
	0xe8	0xf01		FMP_BUILD
	0xe9	0x801		LPB_BUILD
	0xf2	0x304		RTT_BUILD
	0xf3	0x11464901	IRQ_BUILD
	0xf5	0x80503		PCT_BUILD
	0xf6	0x7b0002	CC_BUILD
	0xf7	0x304		PDM_DVFS_BUILD
	0xf8	0x11101		ISA_PROFILE
	0xf9	0x40001		MICRO_ARCH_BUILD
	0xff	0x10003		SMART_BUILD
	0x298	0x0		CLUSTER_ID
	0x901	0x1f441142	SLC_AUX_CACHE_CONFIG
	0x902	0x0		SLC_BCR2
]]></string>
  </configuration>
  <configuration name="build_version_info" filename="build_version_info.txt">
    <string><![CDATA[
Version Information:
    ARChitect O-2018.09
    IP Libraries:
        ARCv2HS            v3.1.61
        ARC Debug          v2.1.6
        ARC RTT            v2.10.5
        ARC xCAM           v4.3.7
        ARConnect          v2.1.18
        ARCv2CC            v2.1.52
        ARCv2HS_CCT        v3.1.61
        ARCv2MSS           v2.1.30
        FastMath           v1.0.3
        Implementation     v3.1.61
        Synopsys Based Reference Design Flow  v9.0.25
        Synopsys Clock Gate Replacement Flow  v3.0.7
        Synopsys Embed-it Integrator Flow  v7.0.18
        Technology Library Data  v0.0.1
        Tool Configuration  v1.0.71
]]></string>
  </configuration>
  <configuration name="mw_compiler" filename="ccac.arg">
    <string><![CDATA[
	-arcv2hs
	-core4
	-Xdual_issue
	-Xcode_density
	-Hrgf_banked_regs=32
	-HL
	-Xatomic
	-Xll64
	-Xunaligned
	-Xdiv_rem=radix4
	-Xswap
	-Xbitscan
	-Xmpy_option=qmpyh
	-Xshift_assist
	-Xbarrel_shifter
	-Xdsp3
	-Xdsp_complex
	-Xdsp_divsqrt=radix4
	-Xdsp_itu
	-Xdsp_accshift=full
	-Xdsp_wide
	-Xagu_small
	-Xfastmath_div
	-Xfastmath_sqrt
	-Xfastmath_sat
	-Xfastmath_trig
	-Xfpud_div
	-Xfpu_mac
	-Xtimer0
	-Xtimer1
	-Xrtc
	-Xstack_check
	-Hld_cycles=2
	-Xlpb_size=128
]]></string>
  </configuration>
  <configuration name="mw_debugger" filename="mdb.arg">
    <string><![CDATA[
	-arcv2hs 
	-core4 
	-Xdual_issue 
	-Xcode_density 
	-rgf_num_banks=2 
	-rgf_banked_regs=32 
	-rgf_num_wr_ports=2 
	-Xatomic 
	-Xll64 
	-Xunaligned 
	-Xdiv_rem=radix4 
	-Xswap 
	-Xbitscan 
	-Xmpy_option=qmpyh 
	-Xshift_assist 
	-Xbarrel_shifter 
	-Xdsp3 
	-Xdsp_complex 
	-Xdsp_divsqrt=radix4 
	-Xdsp_itu 
	-Xdsp_accshift=full 
	-Xdsp_wide 
	-Xagu_small 
	-Xfastmath_div 
	-Xfastmath_sqrt 
	-Xfastmath_sat 
	-Xfastmath_trig 
	-Xfpud_div 
	-Xfpu_mac 
	-Xtimer0 
	-Xtimer0_level=1 
	-Xtimer1 
	-Xtimer1_level=0 
	-Xrtc 
	-action_points=8 
	-ap_feature=1 
	-Xstack_check 
	-volatile_base=15 
	-volatile_limit=0 
	-volatile_strict_ordering 
	-bpu_bc_entries=2048 
	-bpu_pt_entries=16384 
	-bpu_rs_entries=8 
	-bpu_bc_full_tag=1 
	-bpu_tosq_entries=8 
	-bpu_fb_entries=4 
	-smart_stack_entries=64 
	-mpu 
	-mpu_regions=8 
	-mmuv5 
	-mmu_pgsz=8K 
	-mmu_ntlb_entries=1024 
	-mmu_stlb_entries=16 
	-mmu_super_pgsz=2M 
	-mmu_pae40 
	-mmu_sasid 
	-mmu_dtlb_entries=8 
	-mmu_itlb_entries=4 
	-interrupts=73 
	-interrupt_priorities=2 
	-ext_interrupts=70 
	-firq 
	-interrupt_base=0x0 
	-dcache=65536,64,2,a 
	-dcache_feature=2 
	-dcache_mem_cycles=2 
	-icache=65536,64,4,a 
	-icache_feature=2 
	-Xpct_counters=8 
	-Xpct_interrupt 
	-arconnect 
	-connect_ici 
	-connect_ics 
	-connect_ics_num_semas=16 
	-connect_icm 
	-connect_icm_sram_size=512 
	-connect_icm_sram_prot=none 
	-connect_pmu 
	-connect_icd 
	-connect_gfrc 
	-connect_idu 
	-connect_idu_cirqnum=64 
	-connect_pdm 
	-csm 
	-csm_size0=256K 
	-csm_bank_mcycle=4 
	-csm_prot0=none 
	-csm_mpnum=1 
	-csm_base=0xb0000000 
	-cluster_dma 
	-cluster_dma_ch_num=8 
	-cluster_dma_desc_num=64 
	-cluster_dma_max_burst_size=8 
	-cluster_dma_max_pend_trans=8 
	-cluster_dma_buf_size=64 
	-cluster_dma_data_size=64 
	-power_domains 
	-dvfs 
	-Xlpb_size=128 
	-sl2cache=0x80000,128,8,a 
	-slc_version=3 
	-slc_ecc_data_size=32 
	-slc_error_prot=none 
	-scu 
	-scu_stb_entries=8 
	-scu_coherent_io=1 
]]></string>
  </configuration>
  <configuration name="nSIM" filename="nsim.props">
    <string><![CDATA[
	nsim_isa_family=av2hs
	nsim_isa_core=4
	arcver=0x54
	nsim_isa_dual_issue_option=1
	nsim_isa_code_density_option=2
	nsim_isa_rgf_num_banks=2
	nsim_isa_rgf_banked_regs=32
	nsim_isa_rgf_num_regs=32
	nsim_isa_rgf_num_wr_ports=2
	nsim_isa_big_endian=0
	nsim_isa_lpc_size=32
	nsim_isa_pc_size=32
	nsim_isa_addr_size=32
	nsim_isa_atomic_option=1
	nsim_isa_ll64_option=1
	nsim_isa_unaligned_option=1
	nsim_isa_div_rem_option=2
	nsim_isa_swap_option=1
	nsim_isa_bitscan_option=1
	nsim_isa_mpy_option=9
	nsim_isa_shift_option=3
	nsim_isa_dsp_option=3
	nsim_isa_dsp_complex_option=1
	nsim_isa_dsp_divsqrt_option=2
	nsim_isa_dsp_itu_option=1
	nsim_isa_dsp_accshift_option=2
	nsim_isa_dsp_wide_option=1
	nsim_isa_agu=1
	nsim_isa_agu_size=small
	nsim_isa_fmp_div_option=1
	nsim_isa_fmp_sqrt_option=1
	nsim_isa_fmp_sat_option=1
	nsim_isa_fmp_trig_option=1
	nsim_isa_fpud_div_option=1
	nsim_isa_fpu_mac_option=1
	nsim_isa_enable_timer_0=1
	nsim_isa_timer_0_int_level=1
	nsim_isa_enable_timer_1=1
	nsim_isa_timer_1_int_level=0
	nsim_isa_rtc_option=1
	nsim_isa_num_actionpoints=8
	nsim_isa_aps_feature=1
	nsim_isa_stack_checking=1
	nsim_isa_volatile_base=15
	nsim_isa_volatile_limit=0
	nsim_isa_volatile_disable=0
	nsim_isa_volatile_strict_ordering=1
	nsim_bpu_bc_entries=2048
	nsim_bpu_pt_entries=16384
	nsim_bpu_rs_entries=8
	nsim_bpu_bc_full_tag=1
	nsim_bpu_tosq_entries=8
	nsim_bpu_fb_entries=4
	nsim_isa_smart_stack_entries=64
	mpu_regions=8
	mpu_version=3
	nsim_mmu=5
	mmu_pagesize=8K
	mmu_ntlb_ways=4
	mmu_ntlb_sets=256
	mmu_stlb_entries=16
	mmu_super_pagesize=2M
	mmu_pae40_enabled=1
	mmu_sasid=1
	mmu_dtlb_entries=8
	mmu_itlb_entries=4
	nsim_isa_number_of_interrupts=73
	nsim_isa_number_of_levels=2
	nsim_isa_number_of_external_interrupts=70
	nsim_isa_fast_irq=1
	nsim_isa_intvbase_preset=0x0
	dcache=65536,64,2,a
	nsim_isa_dc_feature_level=2
	nsim_isa_dc_mem_cycles=2
	icache=65536,64,4,a
	nsim_isa_ic_feature_level=2
	nsim_isa_pct_counters=8
	nsim_isa_pct_interrupt=1
	nsim_connect=2
	nsim_connect_ici=2
	nsim_connect_ics=1
	nsim_connect_ics_num_semas=16
	nsim_connect_icm=3
	nsim_connect_icm_sram_size=512
	nsim_connect_icm_sram_ecc=0
	nsim_connect_pmu=1
	nsim_connect_icd=2
	nsim_connect_gfrc=3
	nsim_connect_idu=2
	nsim_connect_idu_cirqnum=64
	nsim_connect_pdm=1
	nsim_csm=1
	nsim_csm_size0=256K
	nsim_csm_bank_mcycle=4
	nsim_csm_ecc0=0
	nsim_csm_mpnum=1
	nsim_csm_base=0xb0000000
	nsim_cluster_dma=1
	nsim_cluster_dma_ch_num=8
	nsim_cluster_dma_desc_num=64
	nsim_cluster_dma_max_burst_size=8
	nsim_cluster_dma_max_pend_trans=8
	nsim_cluster_dma_buf_size=64
	nsim_cluster_dma_data_size=64
	nsim_isa_pdm_option=1
	nsim_isa_dvfs_option=1
	nsim_isa_lpb_num=8
	nsim_sl2cache=0x80000,128,8,a
	nsim_slc_version=3
	nsim_slc_ecc_type=0
	nsim_isa_has_scu=1
	nsim_isa_scu_stb_entries=8
	nsim_isa_scu_has_coherent_io=1
	nsim_isa_scu_coherent_io=1
]]></string>
  </configuration>
  <configuration name="IDE" filename="ide.props">
    <string><![CDATA[
	processor.family=5
	processor.core_version=4
	processor.family_name=arcv2hs
	processor.Xdual_issue=1
	processor.Xcode_density=1
	processor.rgf_num_banks=2
	processor.rgf_banked_regs=32
	processor.rgf_num_wr_ports=2
	processor.endian=little
	processor.lpc_size=32
	processor.pc_size=32
	processor.addr_size=32
	processor.Xatomic=1
	processor.Xll64=1
	processor.Xunaligned=1
	processor.Xdiv_rem=radix4
	processor.Xswap=1
	processor.Xbitscan=1
	processor.Xmpy_option=qmpyh
	processor.Xshift_assist=1
	processor.Xbarrel_shifter=1
	processor.Xdsp3=1
	processor.Xdsp_complex=1
	processor.Xdsp_divsqrt=radix4
	processor.Xdsp_itu=1
	processor.Xdsp_accshift=full
	processor.Xdsp_wide=1
	processor.Xagu_small=1
	processor.Xfastmath_div=1
	processor.Xfastmath_sqrt=1
	processor.Xfastmath_sat=1
	processor.Xfastmath_trig=1
	processor.Xfpud_div=1
	processor.Xfpu_mac=1
	processor.Xtimer0=1
	processor.Xtimer0_level=1
	processor.Xtimer1=1
	processor.Xtimer1_level=0
	processor.Xrtc=1
	processor.action_points=8
	processor.ap_feature=1
	processor.Xstack_check=1
	processor.volatile_base=15
	processor.volatile_limit=0
	processor.volatile_strict_ordering=1
	processor.bpu_bc_entries=2048
	processor.bpu_pt_entries=16384
	processor.bpu_rs_entries=8
	processor.bpu_bc_full_tag=1
	processor.bpu_tosq_entries=8
	processor.bpu_fb_entries=4
	processor.smart_stack_entries=64
	processor.mpu=1
	processor.mpu.regions=8
	processor.mmuv5=1
	processor.mmu_pgsz=8K
	processor.mmu_ntlb_entries=1024
	processor.mmu_stlb_entries=16
	processor.mmu_super_pgsz=2M
	processor.mmu_pae40=1
	processor.mmu_sasid=1
	processor.mmu_dtlb_entries=8
	processor.mmu_itlb_entries=4
	processor.interrupts=73
	processor.interrupt_priorities=2
	processor.ext_interrupts=70
	processor.firq=1
	processor.interrupt_base=0x0
	processor.dcache.size=65536
	processor.dcache.line_size=64
	processor.dcache.ways=2
	processor.dcache_feature=2
	processor.dcache_mem_cycles=2
	processor.Hld_cycles=2
	processor.icache.size=65536
	processor.icache.line_size=64
	processor.icache.ways=4
	processor.icache_feature=2
	processor.Xpct_counters=8
	processor.Xpct_interrupt=1
	processor.arconnect=1
	processor.connect_ici=1
	processor.connect_ics=1
	processor.connect_ics_num_semas=16
	processor.connect_icm=1
	processor.connect_icm_sram_size=512
	processor.connect_icm_sram_prot=none
	processor.connect_pmu=1
	processor.connect_icd=1
	processor.connect_gfrc=1
	processor.connect_idu=1
	processor.connect_idu_cirqnum=64
	processor.connect_pdm=1
	processor.csm=1
	processor.csm_size0=256K
	processor.csm_bank_mcycle=4
	processor.csm_prot0=none
	processor.csm_mpnum=1
	processor.csm_base=0xb0000000
	processor.cluster_dma=1
	processor.cluster_dma_ch_num=8
	processor.cluster_dma_desc_num=64
	processor.cluster_dma_max_burst_size=8
	processor.cluster_dma_max_pend_trans=8
	processor.cluster_dma_buf_size=64
	processor.cluster_dma_data_size=64
	processor.power_domains=1
	processor.dvfs=1
	processor.Xlpb_size=128
	processor.sl2cache.size=0x80000
	processor.sl2cache.line_size=128
	processor.sl2cache.ways=8
	processor.slc_version=3
	processor.slc_ecc_data_size=32
	processor.slc_error_prot=none
	processor.scu=1
	processor.scu_stb_entries=8
	processor.scu_coherent_io=1
]]></string>
  </configuration>
  <configuration name="architect" filename="build_configuration.txt">
    <string><![CDATA[
######## architect --- com.arc.templates.project.Empty.1_0 ########

# BuildHTMLDocs --- Creates custom HTML documentation in the 'docs' directory.
-build_html_docs true

# BuildSoftware --- Creates software under the Software directory.
-build_software false

# BuildTestCode --- Creates test source code under the 'tests' directory.
-build_test_code true

# BuildScripts --- Creates synthesis scripts and configuration files, which are required for hierarchy generation.
-build_scripts true

# BuildHDL --- Creates the behavioural and synthesisable HDL source code.
-build_hdl true

# CompileTestCode --- Compiles and assembles the test code.
-compile_test_code false

# GenerateStructuralHDL --- Generate the necessary structural HDL
-generate_structural_hdl true

# CompileForHDLSimulation --- Compile the HDL ready for simulation, using the selected Simulator.
-compile_hdl_for_simulation false

# BuildXCAM --- 
# When true, build the XCAM cycle accurate model from HDL.
# This happens only when the VTOC component (in the XCAM library) has been added to the design.
# 
-build_xcam true

# RunARCsyn --- Synthesize design using ARCsyn
-run_arcsyn false

# RunSEIF --- Run Synopsys Embedit Integrator Flow to generate configured memory instances
-run_seif false

# RunARCrams --- Run ARCrams on the current build, this will stitch in vendor supplied RAM models and update the synthesis and simulation environment to use the models.
-run_arcrams false

# RunARCformal --- Formal Verification using ARCformal
-run_arcformal false

# RunARCpower --- Run the Power Analysis using RTL simulation to derive the activity
-run_arcpower false

# compile_iss_user_extensions --- Build ISS extensions for any APEX components in the current design using their C Models.
-compile_iss_user_extensions false

# compile_translated_iss_extensions --- Converts APEX extensions from Verilog to C++ and compiles the model for the ISS.
-compile_translated_iss_extensions false

# compile_nsim_user_extensions --- Build nSIM extensions for any APEX components in the current design using their C Models.
-compile_nsim_user_extension false

# compile_translated_nsim_extensions --- Converts APEX extensions from Verilog to C++ and compiles the model for nSIM.
-compile_translated_nsim_extensions false


######## System --- com.arc.hardware.System.1_0 ########

# Create System
-create com.arc.hardware.System.1_0 System

# Testbench --- 
# Only the rascal testbench is supported, and is required by ARCtest.
# 	
-testbench rascal

# SynthesisLevel --- 
# Sets the top level module name for synthesis.  
# 
# If not using core_sys: for single-core designs, cpu_isle is used; for multicore designs, archipelago is used.
# 	
-synthesislevel cpu_isle/archipelago

# GateLevelSim --- When selected the gate level sim test code and scripts would be installed to run ARCgatesim
-gatesim true

# UserLibraryName --- The name for your HDL library
-library_name user

# OPTION_SimulatorName --- The name of the simulator you wish to use
-simulator vcs

# sim64 --- When selected, the 64-bit version of the simulator is used.  Be sure you have the 64-bit-capable simulator installed  and $ARCHITECT_ROOT/lib/linux_x86_64/ added to your LD_LIBRARY_PATH.
# The setting of this option affects the content of the generated makefile_interface_*_verilog, where * is the simulator name.
-sim64 true

# verilog_2001 --- Enable Verilog 2001 file-io syntax (if false: use pli)
-verilog_2001 true

# export_srams_to --- Where to place srams, if not cpu_top
-export_srams_to none

# copy_prefix --- 
# A Copy Prefix P causes creation of a separate copy of the entire Verilog build where each Verilog filename, module, and `define is prefixed with P and copied to a separate directory named P.
# 	
-copy_prefix ""


######## Cluster --- com.arc.hardware.CC.Cluster.1_0 ########

# Create Cluster
-create com.arc.hardware.CC.Cluster.1_0 System.Cluster

# cc_def_div2ref --- This specifies the clock division factor at reset. This option is irrelevant to any RTL featuresIt is only used for ARCv2MSS clock controller to generate HS Cluster clock in ARChitect simulation environment, and the value N means this HS Cluster is running at (1/N) x ref_clk.
-cc_def_div2ref 1

# cluster_id --- This number uniquely identifies this cluster from all other clusters.  It is placed in the CLUSTER_ID auxiliary register visible in each core of the cluster.
-cluster_id 0

# vector_proc_profile --- Any scalar HS core(s) within cluster will use the vector unit compatible scalar instruction set.
-vector_proc_profile false

# cc_allow_csm_l2_share_memory --- The memory inside L2 cache can be shared with CSM to accommodate different applications
-cc_allow_csm_l2_share_memory false

# cc_add_ppb_duncach --- Add zero, one or two levels of pipeline stages for the data non-cacheable transactions from each core. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cc_add_ppb_duncach 0

# cc_add_ppb_dcach --- Add zero, one or two levels of pipeline stages for the data cacheable transactions from each core. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cc_add_ppb_dcach 0

# cc_add_ppb_per --- Add zero, one or two levels of pipeline stages for the data peripheral transactions from each core. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cc_add_ppb_per 0

# cc_add_ppb_ifetch --- Add zero, one or two levels of pipeline stages for the instruction fetch transactions from each core. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cc_add_ppb_ifetch 0

# cc_add_ppb_scu --- Add zero, one or two levels of pipeline stages for the transactions from Shared Coherent Unit (SCU) to downstream L2 Cache (if L2 Cache has been configured) or memory bus initiator port (if L2 Cache has not been configured). This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency. Please note this option is only relevant when Shared Coherent Unit (SCU) has been configured.
-cc_add_ppb_scu 0

# cc_add_ppb_snp --- Add zero, one or two levels of pipeline stages for the snooping transactions from Shared Coherent Unit (SCU) to each core. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency. Please note this option is only relevant when Shared Coherent Unit (SCU) has been configured.
-cc_add_ppb_snp 0

# cc_add_ppb_l2c --- Add zero, one or two levels of pipeline stages for the L2 Cache-miss transactions to BIU memory bus initiator port. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency. Please note this option is only relevant when L2 Cache has been configured.
-cc_add_ppb_l2c 0

# cc_uaux_num --- This specifies the number of Cluster_uAUX interfaces. For example: if specifies 4, there will be Cluster_uAUX0/Cluster_uAUX1/Cluster_uAUX2/Cluster_uAUX3 configured out
-cc_uaux_num 0

# cc_xnn_uaux_num --- This specifies the number of Cluster_Extension_uAUX interfaces. For example: if specifies 4, there will be Cluster_Extension_uAUX0/Cluster_Extension_uAUX1/Cluster_Extension_uAUX2/Cluster_Extension_uAUX3 configured out
-cc_xnn_uaux_num 0

# cc_xnn_uaux0_client --- This names the interface instance so it can be connected to by a client using the same name.  In the absence of a client name, the interface is stubbed.
-cc_xnn_uaux0_client ""

# cc_xnn_uaux1_client --- This names the interface instance so it can be connected to by a client using the same name.  In the absence of a client name, the interface is stubbed.
-cc_xnn_uaux1_client ""

# cc_xnn_uaux2_client --- This names the interface instance so it can be connected to by a client using the same name.  In the absence of a client name, the interface is stubbed.
-cc_xnn_uaux2_client ""

# cc_xnn_uaux3_client --- This names the interface instance so it can be connected to by a client using the same name.  In the absence of a client name, the interface is stubbed.
-cc_xnn_uaux3_client ""

# instances --- Description to follow
-instances 1

# unique_name --- Description to follow
-unique_name ""


######## System-level cache --- com.arc.hardware.CC.System_level_cache.1_0 ########

# Create System-level cache
-create com.arc.hardware.CC.System_level_cache.1_0 "System.Cluster.System-level cache"

# slc_size --- This specifies the size of the cache.
-slc_size 524288

# slc_line_size --- This specifies the line size.
-slc_line_size 128

# slc_ways --- This specifies the number of ways.
-slc_ways 8

# slc_tag_banks --- This specifies the number of tag banks.
-slc_tag_banks 4

# slc_tram_delay --- This specifies the cycle delay for the tag RAM.
-slc_tram_delay 1

# slc_data_banks --- This specifies the number of data banks.
-slc_data_banks 8

# slc_dram_delay --- This specifies the cycle delay for the data RAM.
-slc_dram_delay 2

# slc_data_halfcycle_steal --- Share slack from slc_data memory latency by clocking slc data rams 0.5 cycle later.  Adds a register in front of slc_data_ram and clocks slc_data_ram on negedge of clock. Option only used when slc_data_size >= 512KB
-slc_data_halfcycle_steal true

# slc_data_add_pre_pipeline --- Adds a register in front of slc_data_ram effectively increasing the configured latency by 1 cycle. Raises ceiling on Fmax for large complex multicores. Option only used when slc_data_size >= 512KB
-slc_data_add_pre_pipeline false

# slc_tag_add_pipeline --- Adds a register in tag stge effectively increasing the configured latency by 1 cycle. Raises ceiling on Fmax for large complex multicores
-slc_tag_add_pipeline false

# slc_clock_gating --- This enables the insertion of architectural clock gate elements in the design. By enabling this option, the clocks to various functional units are gated off when the unit they drive is not in use. Used for power saving especially when state dependent clock gating would not be enabled for synthesis. Configure to false for certain FPGA tools when they have problem handling a cascade of architectural clock gates
-slc_clock_gating false

# slc_mem_bus_width --- Width of data connection to external memory
-slc_mem_bus_width 64

# slc_ecc_option --- Specifies the type of protection for the memories.
-slc_ecc_option None

# slc_data_ecc_csize --- Selects 32 bit or 64 bit ECC for data Memory
-slc_data_ecc_csize 0

# userslcfloorplan_path --- Pathname +filename of user-defined floorplan for the SLC (slc_top) when using a fully hierarchical implementation
-userslcfloorplan_path ""

# slc_floorplan --- Specifies if floorplan is passed by user via  userslcfloorplan_path or using a supplied templated floorplan
-slc_floorplan none

# skip_build --- Customers cannot see this option.  If set, this component is not built.  This saves time if you've already built the design and no subsequent change requires this component to be rebuilt.
-skip_build false


######## Coherency unit --- com.arc.hardware.CC.Coherency_unit.1_0 ########

# Create Coherency unit
-create com.arc.hardware.CC.Coherency_unit.1_0 "System.Cluster.Coherency unit"

# has_coherent_dma --- This specifies whether coherent I/O through the system bus is supported
-has_coherent_dma true

# stb_entries --- Maximum number of active coherency transactions
-stb_entries 8

# scu_has_trace --- Include a trace facility for coherency and copy-back traffic
-scu_has_trace false

# scu_trace_size --- Select the number of entries in the coherency trace buffer. 
-scu_trace_size 1024

# scu_allow_spec_reads --- Allow SCU to make speculative reads from SLC
-scu_allow_spec_reads false

# skip_build --- Customers cannot see this option.  If set, this component is not built.  This saves time if you've already built the design and no subsequent change requires this component to be rebuilt.
-skip_build false


######## Cluster DMA --- com.arc.hardware.CC.Cluster_DMA.1_0 ########

# Create Cluster DMA
-create com.arc.hardware.CC.Cluster_DMA.1_0 "System.Cluster.Cluster DMA"

# dma_srv_num_chan --- Number of channels in the DMA server.
-dma_srv_num_chan 8

# dma_srv_num_descr --- Total number of descriptors in the DMA server
-dma_srv_num_descr 64

# dma_srv_max_burst --- DMA server maximum burst size for bus transactions
-dma_srv_max_burst 8

# dma_srv_max_trans --- Maximum number of pending bus transactions
-dma_srv_max_trans 8

# dma_srv_buf_size --- DMA server data buffer size in word entries
-dma_srv_buf_size 64

# dma_srv_data_size --- DMA server data buffer size in word entries
-dma_srv_data_size 64

# dma_srv_data_buf_implementation --- DMA server data buffer implementation
-dma_srv_data_buf_implementation flip-flop

# dma_srv_desc_mem_implementation --- DMA server descriptor memory implementation
-dma_srv_desc_mem_implementation memory

# dma_srv_support_coherency --- DMA server support coherency check for all L1 Dcaches within the cluster by hardware
-dma_srv_support_coherency false


######## Cluster shared memory --- com.arc.hardware.CC.Cluster_shared_memory.1_0 ########

# Create Cluster shared memory
-create com.arc.hardware.CC.Cluster_shared_memory.1_0 "System.Cluster.Cluster shared memory"

# csm_bank_mcycle --- This specifies the access cycle number for each CSM SRAM bank.
-csm_bank_mcycle 4

# csm_partition_num --- This specifies the number of partitions of the CSM memory
-csm_partition_num 1

# csm_size --- This specifies the number of Kbytes of the CSM memory size for partition 0 Or the total size of CSM when  number of partitions is configured as 1.
-csm_size 256

# csm_ecc --- none = No checking; parity = Parity check only; SECDED= Single-error correction and double-error detection (SECDED).
-csm_ecc none

# csm_size_1 --- This specifies the number of Kbytes of the CSM memory size for partition 1.
-csm_size_1 32

# csm_ecc_1 --- none = No checking; parity = Parity check only; SECDED= Single-error correction and double-error detection (SECDED).
-csm_ecc_1 SECDED

# csm_bist_option --- This specifies whether multi-memory bus (MMB) BIST interface for CSM is configured or not
-csm_bist_option false

# csm_has_dmi --- This specifies whether CSM-DMI port is configured or not. 
-csm_has_dmi false

# csm_dmi_dw --- This specifies the data width of the CSM-DMI port
-csm_dmi_dw 32

# csm_dmi_type --- This specifies the protocol to access CSM from external bus devices.
-csm_dmi_type AXI

# csm_dmi_axi_idw --- This specifies the AXI ID width of the CSM-DMI port. This option is only valid when the CSM-DMI port is configured as AXI protocol.
-csm_dmi_axi_idw 8

# csm_add_pipe_stage --- Place one more pipeline stage on CSM. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-csm_add_pipe_stage 0

# csm_region --- NOTE: This option is irrelevant to any RTL features. It is only used for ARCv2MSS based ARChitect simulation environment to generate the default value of csm_sys_base_addr input signal, and also facilitate CCT tests simulation.
-csm_region 11

# csm_region_hi --- When the configured physical address size of an ARC HS processor exceeds 32-bits, this option is introduced to set the CSM base address beyond the 32-bit address range in ARChitect simulation environment. For example, if the physical address width is 40-bits, the -csm_region is set as 2, and the -csm_region_hi is set as 255, then the CSM base address is 0xff_2000_0000. NOTE: This option is irrelevant to any RTL features. It is only used for ARCv2MSS based ARChitect simulation environment to generate the default value of csm_sys_base_addr input signal, and also facilitate CCT tests simulation.
-csm_region_hi 0

# skip_build --- Customers cannot see this option.  If set, this component is not built.  This saves time if you've already built the design and no subsequent change requires this component to be rebuilt.
-skip_build false


######## Bus interface unit --- com.arc.hardware.CC.Bus_interface_unit.1_0 ########

# Create Bus interface unit
-create com.arc.hardware.CC.Bus_interface_unit.1_0 "System.Cluster.Bus interface unit"

# biu_mem_bus_num --- This specifies the number of memory busses. 
# This option is ignored if a System-level cache is present, as the number of busses is computed automatically.
-biu_mem_bus_num 1

# biu_mem_bus_option --- Protocol to connect to external memory. Please NOTE that BVCI is supported only for single core builds.
-biu_mem_bus_option AXI

# biu_mem_bus_data_w --- This specifies the data width of the memory busses
-biu_mem_bus_data_w 64

# biu_mem_bus_add_pipe_stage --- Place one more pipeline stage on memory initiator port. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-biu_mem_bus_add_pipe_stage false

# biu_mem_dedicated_bus --- True: Each core have dedicated memory initiator ports group; False: Only one group of memory initiator ports for entire cluster shared by all cores.
-biu_mem_dedicated_bus false

# biu_per_bus_num --- This option is only valid when any of the connected core has component dmp_peripheral configured on.
-biu_per_bus_num 0

# biu_per0_bus_option --- Protocol to connect to external peripherals. This option is only valid when any of the connected core has DMP PERIPHERAL0 component configured on. Please NOTE that BVCI is supported only for single core builds.
-biu_per0_bus_option AXI

# biu_per0_bus_data_w --- This specifies the data width of the peripheral initiator bus0
-biu_per0_bus_data_w 32

# biu_per0_dedicated_bus --- True: Each core have dedicated peripheral initiator port ; False: Only one peripheral initiator port for entire cluster shared by all cores.
-biu_per0_dedicated_bus false

# biu_per0_bus_add_pipe_stage --- Place one more pipeline stage on peripheral initiator port. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-biu_per0_bus_add_pipe_stage false

# biu_per1_bus_option --- Protocol to connect to external peripherals. This option is only valid when any of the connected core has DMP PERIPHERAL1 component configured on. Please NOTE that BVCI is supported only for single core builds.
-biu_per1_bus_option AXI

# biu_per1_bus_data_w --- This specifies the data width of the peripheral initiator bus1
-biu_per1_bus_data_w 32

# biu_per1_dedicated_bus --- True: Each core have dedicated peripheral initiator port ; False: Only one peripheral initiator port for entire cluster shared by all cores.
-biu_per1_dedicated_bus false

# biu_per1_bus_add_pipe_stage --- Place one more pipeline stage on peripheral initiator port. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-biu_per1_bus_add_pipe_stage false

# biu_dmi_bus_num --- This option is only valid when any of the connected core has iccm0_dmi/iccm1_dmi/dccm_dmi configured on. Option 0: No target bus interface for ICCMs and DCCMs; Option 1: All cores ICCMs and DCCMs share same target bus interface; Option 2: All cores ICCMs have dedicated target bus interface, and all cores DCCMs have another dedicated target bus interface.
-biu_dmi_bus_num 1

# biu_dmi_bus_option --- This specifies the protocol of the DMI busses. Please NOTE that BVCI is supported only for single core builds.
-biu_dmi_bus_option AXI

# biu_dmi_bus_data_w --- This specifies the data width of the DMI busses
-biu_dmi_bus_data_w 64

# biu_dmi_bus_axi_idw --- This speciries the AXI ID width of the DMI busses. This option is only valid when the DMI port is configured as AXI protocol.
-biu_dmi_bus_axi_idw 16

# biu_dmi_add_pipe_stage --- Place one more pipeline stage on DMI bus bridge. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-biu_dmi_add_pipe_stage false

# biu_udmi_bus_num --- Option 1 , all slave components within HS cluster are accessed via one unified slave interface, including ICCM0/ICCM1/DCCM/VMEM of each processor core, STU (streaming transfer unit), CSM, as well as the IOC bus. Option 0, there are dedicated DMI interfaces (such as DMI port, VMEM DMI port, STU_DMI, CSM_DMI) and dedicated IOC bus for slave accessing.
-biu_udmi_bus_num 0

# biu_udmi_support_ioc --- This specifies whether this unified slave port supports accessing to coherency space (like IOC port of HS cluster) or not. 
-biu_udmi_support_ioc false

# biu_udmi_ioc_full_coherent --- This specifies whether the transactions from the unified slave port targeting coherency space are fully coherent or not. If fully coherent, the transactions will directly route to SCU for coherency snooping, otherwise, an internal address decoder will judge whether the transactions fall into coherency region, or non-coherent CSM or external memory space. NOTE: When fully coherent, there will no AUX register to define I/O coherency region. While non-fully coherent, AUX registers (such as COH_EN/COH_AP/COH_BASE) will be used to define the I/O coherency region 
-biu_udmi_ioc_full_coherent false

# biu_udmi_access_per1 --- This specifies whether this unified slave port supports accessing to second peripheral port or not. 
-biu_udmi_access_per1 false

# biu_udmi_bus_option --- This specifies the protocol of the unified slave port.
-biu_udmi_bus_option AXI

# biu_udmi_bus_data_w --- This specifies the data width of the unified slave port.
-biu_udmi_bus_data_w 64

# biu_udmi_bus_axi_idw --- This speciries the AXI ID width of the unified slave port. This option is only valid when it's configured as AXI protocol.
-biu_udmi_bus_axi_idw 16

# biu_udmi_add_pipe_stage --- Place one more pipeline stage on unified slave bus bridge. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-biu_udmi_add_pipe_stage false

# biu_ioc_bus_num --- This specifies the number of I/O coherency busses. NOTE: the bus protocol and data width of IOC port is specified by -biu_mem_bus_option
-biu_ioc_bus_num 1

# biu_xnn_ioc_bus_num --- This specifies the number of I/O coherency busses dedicated for ARC internal components, e.g., CNN2.0. NOTE: the bus protocol and data width of IOC port is specified by -biu_mem_bus_option
-biu_xnn_ioc_bus_num 0

# biu_xnn_ioc_bus0_client --- This names the interface instance so it can be connected to by a client using the same name.
-biu_xnn_ioc_bus0_client ""

# biu_xnn_ioc_bus1_client --- This names the interface instance so it can be connected to by a client using the same name.
-biu_xnn_ioc_bus1_client ""

# biu_xnn_ioc_bus2_client --- This names the interface instance so it can be connected to by a client using the same name.
-biu_xnn_ioc_bus2_client ""

# biu_xnn_ioc_bus3_client --- This names the interface instance so it can be connected to by a client using the same name.
-biu_xnn_ioc_bus3_client ""

# biu_ioc_add_pipe_stage --- Place one more pipeline stage on IOC bus bridge. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-biu_ioc_add_pipe_stage false

# biu_ioc_bus_axi_idw --- This specifies the AXI ID width of the IOC bus. This option is only valid when the IOC port is configured as AXI protocol.
-biu_ioc_bus_axi_idw 8

# biu_ioc_ahbl_ebt --- This option only relevant when the IOC port is configured as AHB-Lite protocol. True: the incoming AHB-Lite burst (INCR4/INCR8/INCR16/WRAP4/WRAP8/WRAP16) transactions could be early terminated, hence the AHB-Lite transaction will always be split into single-beat internal bus transaction, the performance is low. False: the incoming AHB-Lite burst (INCR4/INCR8/INCR16/WRAP4/WRAP8/WRAP16) transactions will never be early terminated, hence the AHB-Lite transaction will be converted into burst internal bus transaction as much as possible, the performance is high.
-biu_ioc_ahbl_ebt true

# biu_disable_unit_clkg --- Configure this option to be 1 will remove the BIU unit-level clock gating to easy timing closure
-biu_disable_unit_clkg 0

# skip_build --- Customers cannot see this option.  If set, this component is not built.  This saves time if you've already built the design and no subsequent change requires this component to be rebuilt.
-skip_build false


######## CPUisle__0 --- com.arc.hardware.HS.CPU_isle.1_0 ########

# Create CPUisle__0
-create com.arc.hardware.HS.CPU_isle.1_0 System.Cluster.CPUisle__0

# unique_name --- verilog module modifier prefix
-unique_name c0

# ArcNum --- The processor number as read back in the ARCNUM field of the IDENTITY register.
-arc_num 0

# instances --- 
# The number of instantiations of this core.
# 
-instances 1

# instance_signal_prefix --- 
# [arc_dev] Specifies the prefix used for each instance, when multiple instances are created.  If N is in the text, N is replaced by the instance number; otherwise the instance number is appended.
# 
-instance_signal_prefix c

# skip_vpp --- 
# This is a secret option, not seen by customers.
# If you check this, we won't VPP most of the *.vpp files.
# This can speed up re-build if you've already built them and not
# changed the core options.
# Use at your own risk.
# 	
-skip_vpp false

# OPTION_remove_tmpdir --- 
# This is a secret option, not seen by customers.
# If you uncheck this, we'll leave in place the temporary directory in which RTL is generated to support unique_name.
# 	
-remove_tmpdir true

# CPUFloorplan --- Floorplan giving relative placement of the RAMs  for the given configuration of ARCv2HS or ARCv2EM in this CPUisle
-cpu_floorplan User

# userCPUFloorplanPath --- Pathname of user floorplan for the CPU when using a hierarchical implementation
-usercpufloorplan_path /slowfs/de02dwt2p038/Gen2_libs/arc/iplib/RDF/floorplans/arc_hs38x4_alb_cpu_top_floorplan.tcl

# pinLocationConstraintsFile --- Pathname+filename of the physical pin location constraints file or just "side1" (all pins on l.h.s) or "side2" (pins on top only) or "side3" (pins on r.h.s. only) or "side4" (pins on bottom only) to get a template file generated
-pin_location_constraints_file /slowfs/de02dwt2p038/Gen2_libs/arc/iplib/RDF/floorplans/arc_hs38x4_alb_cpu_top_pin_location_constraints.tcl


######## ARCv2HS --- com.arc.hardware.HS.ARCv2HS.1_0 ########

# Create ARCv2HS
-create com.arc.hardware.HS.ARCv2HS.1_0 System.Cluster.CPUisle__0.ARCv2HS

# halt_on_reset --- This defines whether the core is halted initially on reset.
-halt_on_reset true

# byte_order --- This defines the endianness of the core.
-byte_order little

# atomic_option --- This option enables the LLOCK/SCOND (and LLOCKD/SCONDD if ll64_option) instructions
-atomic_option true

# div_rem_option --- The DIV/REM option adds non-blocking multi-cycle implementation of integer divide/remainder functions. Added instructions are DIV, DIVU (integer divide), REM and REMU (integer divide remainder).radix4_enhanced takes 3 to 19 cycles per operation.
-div_rem_option none

# mpy_option --- The Multiplier ISA option allows selection between several multiplier configurations to tradeoff performance with silicon area. Cycle count for all multiply options is fixed:  4 clocks latency with sustained throughput of 1 clock per instruction, including back-to-back multiply-accumulate operations.
# Note that some vector-add/sub operations are included with certain multiply options, in order to enhance performance of light DSP code.
# <pre>
# 
# 
#  option         Instructions
#  ----------     -------------------------------
#       
#  none                       None 
#  mpy                        MPYW/U, MPY/U, MPYH/U
#  plus_dmpy      mpy       + DMACH, DMPYH, MAC, 
#                             VADD2H,..
#  plus_macd      plus_dmpy + MACD, MPYD, 
#                             VMPY2H,...
#  plus_qmacw     plus_macd + DMACWH, DMPYWH,
#                             QMACH, QMPYH,
#                             VADD2,...
# </pre>
# 
-mpy_option none

# stack_checking --- Stack checking is a mechanism for checking stack accesses and raising an exception when a stack overflow or underflow is detected.
-stack_checking true

# ll64_option --- This enables support for Load and Store instructions that transfer register pairs to/from memory.
-ll64_option true

# intvbase_preset --- This sets the upper 22 bits of the interrupt vector base configuration register, VECBASE_AC_BUILD.  On reset, that register is loaded into the interrupt vector base address register, INT_VECTOR_BASE.  Because this value is the upper 22 bits, the vector base is aligned to a 1K-byte boundary.
-intvbase_preset 0x0

# intvbase_ext --- Set this option to drive the upper 22 bits of the interrupt base vector externally, using signal intvbase_in.
-intvbase_ext false

# nmi_option --- Set this option to enable non-maskable interrupt. 
-nmi_option false

# rgf_num_regs --- This defines the size (in 32b registers) of the processor register file.
-rgf_num_regs 32

# rgf_num_banks --- two or more register banks are useful when Fast IRQ option is selected, but multiple banks may be selected even without Fast IRQ.
-rgf_num_banks 2

# infer_alu_adder --- infer: datapath is described as behavioral code: A + B
# instantiate: datapath is instantiated as a detailed multi-stage code of a carry-lookahead adder.  It is generally preferable to use the infer option when using DesignWare library components and add directives for your target synthesizer.
-infer_alu_adder instantiate

# infer_mpy_wtree --- infer: datapath is described as behavioral code: A * B
# instantiate: datapath is instantiated as a detailed multi-stage code of a Wallace Tree multiplier.   It is preferable  to use the instantiate option; the infer option is intended for simulation only.
-infer_mpy_wtree instantiate

# aux_volatile_base --- Sets the initial base memory region (inclusive) assignment for volatile system memory
-aux_volatile_base 15

# aux_volatile_limit --- Sets the initial upper limit (exclusive) memory region assignment for volatile system memory
-aux_volatile_limit 0

# aux_volatile_disable --- Sets the initial value of Disable Volatile Region bit (on reset)
-aux_volatile_disable false

# aux_volatile_strict_ordering --- Sets the initial value of Strict Ordering bit for the volatile region (on reset)
-aux_volatile_strict_ordering true

# bist_option --- MMB bus on cpu port and accessibility of memories through MMB bus for BIST.
-bist_option false

# scantest_ram_bypass_mux --- This mux is used to make logic trapped between flops and memory (aka shadow logic) to be covered by scantest without requiring advanced sequential ATPG on the memory to be applied. Will add delay to functional access time
-scantest_ram_bypass_mux false

# power_domains --- Add power domains and propagates power-gate control signals to the top level. Also generates UPF constraints and commands in the low-power scripts
-power_domains true

# isolate_has_cdc --- Add 2 flip-flop synchronization registers for isolation signals when they are crossed different clock domain
-isolate_has_cdc false

# pd1_clk_gate_ctrl --- provide an input port to gated/ungated PD1 domain clock
-pd1_clk_gate_ctrl false

# pwr_up_on_int --- Place interrupt and timer logic in core's always-on power domain to support wake-up on interrupt or timer expiry
-pwr_up_on_int false

# dvfs --- Add logics to allow dynamic controlling of voltage and frequency and propagates the associated control signals to the top level
-dvfs true

# clock_gating --- This enables the insertion of architectural clock gate elements in the design. By enabling this option, the clocks to various parts of the design will be disabled when the logic they drive is not in use to save power.
-clock_gating true

# cpu_top_add_ppb_dccm_dmi --- Add a pipeline stage for DCCM DMI. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_dccm_dmi false

# cpu_top_add_ppb_lqwq_mem --- Add a pipeline stage for LQWQ MEM. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_lqwq_mem false

# cpu_top_add_ppb_lqwq_per0 --- Add a pipeline stage for LQWQ PER0. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_lqwq_per0 false

# cpu_top_add_ppb_lqwq_per1 --- Add a pipeline stage for LQWQ PER1. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_lqwq_per1 false

# cpu_top_add_ppb_dcache_rf --- Add a pipeline stage for DCACHE RF. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_dcache_rf false

# cpu_top_add_ppb_dcache_cb --- Add a pipeline stage for DCACHE CB. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_dcache_cb false

# cpu_top_add_ppb_iccm0_dmi --- Add a pipeline stage for ICCM0 DMI. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_iccm0_dmi false

# cpu_top_add_ppb_iccm1_dmi --- Add a pipeline stage for ICCM1 DMI. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_iccm1_dmi false

# cpu_top_add_ppb_icache_rf --- Add a pipeline stage for ICACHE RF. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_icache_rf false

# has_biu --- Use internal BIU instead of the cluster BIU. 
-has_biu false

# br_bc_entries --- The number of entries in the branch cache of the branch prediction unit. An entry can store information about 2 branch or jump instructions. More entries means that the branch predictor can keep track of more branch instructions at the same time.
-br_bc_entries 2048

# br_pt_entries --- The number of 2-bit predictors in the branch prediction unit to predict the direction (taken or not taken) of conditional branches. The prediction algorithm is Gshare. More entries means more bits of global branch history can be tracked for more branch or jump instructions at the same time.
-br_pt_entries 16384

# br_rs_entries --- The number of entries in the return address stack of the branch prediction unit. For subroutine calls and returns the return address is predicted using this stack. More entries means deeper subroutine nesting levels can be predicted accurately.
-br_rs_entries 8

# br_bc_full_tag --- The size of the tag used in the branch cache of the branch prediction unit. A full size tag avoids aliasing of branches in the branch cache, but is more costly in hardware.
-br_bc_full_tag true

# br_bc_tag_size --- If a partial tag is used, this option sets the size of that tag. The chance of aliasing declines exponentially with the size of the tag and in a lot of applications a small tag works fine.
-br_bc_tag_size 4

# br_tosq_entries --- The Top-Of-Stack queue keeps track of subroutine calls and returns that are in progress at the same time in the processor. A small number saves hardware, a large number gives highest performance even when there are dense subroutine call and return patterns.
-br_tosq_entries 8

# br_fb_entries --- The size of the instruction buffer that stores instructions that have been fetched but not yet executed in the processor. A larger buffer allows better performance on complex branch and jump patterns at the expense of hardware.
-br_fb_entries 4

# lpb_num --- 0 indicates no loop buffer configured. This specifies the size of loop buffer.A larger buffer number allows better power saving on longer loop at the expense of hardwareFor instruction lp, lpcc, dbnz, access from loop buffer instead of icache, iccm, external bus and bpu.After detection of the loop, capture these instructions of the loop in the loop buffer.These instructions will be sent to fetch buffer
-lpb_num 8

# grad_entries --- Graduation entries track post-commit instructions awaiting result retirement. For example, long non-blocking instructions such as divide or certain deeply pipelined APEX instructions.
-grad_entries 8

# uaux_option --- Include a user auxiliary register interface
-uaux_option false


######## AGU --- com.arc.hardware.HS.AGU.1_0 ########

# Create AGU
-create com.arc.hardware.HS.AGU.1_0 System.Cluster.CPUisle__0.ARCv2HS.AGU

######## ARCHS_dual_issue --- com.arc.hardware.HS.ARCHS_dual_issue.1_0 ########

# Create ARCHS_dual_issue
-create com.arc.hardware.HS.ARCHS_dual_issue.1_0 System.Cluster.CPUisle__0.ARCv2HS.ARCHS_dual_issue

######## DSP --- com.arc.hardware.HS.DSP.1_0 ########

# Create DSP
-create com.arc.hardware.HS.DSP.1_0 System.Cluster.CPUisle__0.ARCv2HS.DSP

# dsp_itu --- Enable/disable support for ITU bit-accurate 1 bit fractional shift before accumulation, else 1-bit fractional shift result after accumulation only
-dsp_itu true

# dsp_divsqrt --- Enable/disable support for divide and square root operations: DIV(U)(F), REM(U), SQRT(F)
-dsp_divsqrt radix4

# dsp_wide --- Enable/disable support for 4x16x16 and 2x32x16 MAC instructions
-dsp_wide true

# dsp_impl --- The datapath components may be inferred from Verilog for better area or optimized using carry-save components for better timing
-dsp_impl optimized


######## FastMath --- com.arc.hardware.FastMath.1_0 ########

# Create FastMath
-create com.arc.hardware.FastMath.1_0 System.Cluster.CPUisle__0.ARCv2HS.FastMath

# FastMath --- Command line option for EIA extension component 'FastMath'.
-fastmath ""

# support_div --- Include recip & div inst
-support_div true

# support_sqrt --- Include sqrt inst
-support_sqrt true

# support_sat --- Include sath rndh & adds inst
-support_sat true

# support_trig --- Include trig log2 & exp2 inst
-support_trig true


######## Floating-point unit --- com.arc.hardware.HS.Floating_point_unit.1_0 ########

# Create Floating-point unit
-create com.arc.hardware.HS.Floating_point_unit.1_0 "System.Cluster.CPUisle__0.ARCv2HS.Floating-point unit"

# fpu_dp_option --- This enables double-precision floating point instructions.
-fpu_dp_option true

# fpu_div_option --- This enables divide & square-root instructions
-fpu_div_option true

# fpu_fma_option --- This enables the multiply & accumulate instructions.
-fpu_fma_option true


######## Interrupt Controller --- com.arc.hardware.HS.Interrupt_Controller.1_0 ########

# Create Interrupt Controller
-create com.arc.hardware.HS.Interrupt_Controller.1_0 "System.Cluster.CPUisle__0.ARCv2HS.Interrupt Controller"

# number_of_interrupts --- This is the total number of interrupts available to the core.  Some interrupts are allocated statically to a specific interrupt line (for example, timer interrupts).  For more information on Interrupt and register-file options, see DesignWare ARCv2 ISA Programmers Reference Manual.
-number_of_interrupts 73

# number_of_levels --- Priority levels in the interrupt controller.
-number_of_levels 2

# external_interrupts --- This is the total number of interrupt pins available for external system components.  This parameter must be less than the total number of interrupts.
-external_interrupts 70

# firq_option --- This enables the fast-interrupts option, (priority level 0 interrupts), which uses an alternate register bank (if configured) instead of saving the context to memory.
-firq_option true


######## Real-time Counter --- com.arc.hardware.HS.Real_time_Counter.1_0 ########

# Create Real-time Counter
-create com.arc.hardware.HS.Real_time_Counter.1_0 "System.Cluster.CPUisle__0.ARCv2HS.Real-time Counter"

######## Timer 0 --- com.arc.hardware.HS.Timer_0.1_0 ########

# Create Timer 0
-create com.arc.hardware.HS.Timer_0.1_0 "System.Cluster.CPUisle__0.ARCv2HS.Timer 0"

# timer_0_int_level --- This sets the interrupt level (and implicitly the priority: level 0 is highest) of timer 0.
-timer_0_int_level 1


######## Timer 1 --- com.arc.hardware.HS.Timer_1.1_0 ########

# Create Timer 1
-create com.arc.hardware.HS.Timer_1.1_0 "System.Cluster.CPUisle__0.ARCv2HS.Timer 1"

# timer_1_int_level --- This sets the interrupt level (and implicitly the priority: level 0 is highest) of timer 1.
-timer_1_int_level 0


######## Data Cache --- com.arc.hardware.HS.Data_Cache.1_0 ########

# Create Data Cache
-create com.arc.hardware.HS.Data_Cache.1_0 "System.Cluster.CPUisle__0.ARCv2HS.Data Cache"

# dc_size --- This defines the total size of the Data Cache in bytes.
-dc_size 65536

# dc_bsize --- This defines the cache line length in bytes.
-dc_bsize 64

# dc_bus_data_width --- This defines the cache bus width for refills and evictions.
-dc_bus_data_width 64

# dc_mem_cycles --- This defines the number of cycles dedicated to the Data Cache data memories.
-dc_mem_cycles 2

# dc_mem_posedge --- This option clocks the Data Cache memories on the positive edge of the clock
-dc_mem_posedge false

# dc_ecc_option --- This specifies error checking for DCACHE Tag, Data rams.
# SECDED means single-error correction and double-error detection.
-dc_ecc_option none


######## Instruction Cache --- com.arc.hardware.HS.Instruction_Cache.1_0 ########

# Create Instruction Cache
-create com.arc.hardware.HS.Instruction_Cache.1_0 "System.Cluster.CPUisle__0.ARCv2HS.Instruction Cache"

# ic_size --- This defines the total size of the instruction cache in bytes.
-ic_size 65536

# ic_ways --- This defines the number of cache ways
-ic_ways 4

# ic_bsize --- This defines the cache line length in bytes.
-ic_bsize 64

# ic_disable_on_reset --- The instruction cache may be enabled immediately after reset, depending on this option.  If this option is set to true, the instruction cache is disabled and instruction fetches bypass the cache, accessing system memory directly.
-ic_disable_on_reset false

# ic_pipeline_bus --- This option inserts a pipeline register on the instruction cache's refill bus from memory. This option can be used to ease timing in configurations where cores are not closely located with level-2 cache, for example.
-ic_pipeline_bus true

# ic_ecc_option --- This specifies error checking for ICACHE Tag, Data rams.
# SECDED means single-error correction and double-error detection.
-ic_ecc_option none


######## JTAG Interface --- com.arc.hardware.HS.JTAG_Interface.1_0 ########

# Create JTAG Interface
-create com.arc.hardware.HS.JTAG_Interface.1_0 "System.Cluster.CPUisle__0.ARCv2HS.JTAG Interface"

######## Debug Interface --- com.arc.hardware.HS.Debug_Interface.1_0 ########

# Create Debug Interface
-create com.arc.hardware.HS.Debug_Interface.1_0 "System.Cluster.CPUisle__0.ARCv2HS.Debug Interface"

# dbg_en_option --- Adds an enable pin to the existing debug interface
-dbg_en_option false

# dbg_apb_option --- Adds an additional APB debug port alongside the BVCI one
-dbg_apb_option false

# dbg_apb_ratio --- Sets the clock ratio for the APB debug port to core clock
-dbg_apb_ratio 12


######## Actionpoints --- com.arc.hardware.HS.Actionpoints.1_0 ########

# Create Actionpoints
-create com.arc.hardware.HS.Actionpoints.1_0 System.Cluster.CPUisle__0.ARCv2HS.Actionpoints

# num_actionpoints --- This is the number of trigger events available.
-num_actionpoints 8

# aps_feature --- Selects Actionpoint feature set
-aps_feature full


######## SmaRT --- com.arc.hardware.HS.SmaRT.1_0 ########

# Create SmaRT
-create com.arc.hardware.HS.SmaRT.1_0 System.Cluster.CPUisle__0.ARCv2HS.SmaRT

# smart_stack_entries --- This specifies the number of entries in the trace buffer.
-smart_stack_entries 64

# smart_implementation --- Flip-flop = FF-based design.  Memory = memory-based design (provides better density for larger trace buffers).
-smart_implementation memory


######## Real-time trace producer --- com.arc.hardware.HS.Real_time_trace_producer.1_0 ########

# Create Real-time trace producer
-create com.arc.hardware.HS.Real_time_trace_producer.1_0 "System.Cluster.CPUisle__0.ARCv2HS.Real-time trace producer"

# rtt_feature_level --- 'small' means that program trace only is available.  `medium' adds data trace.  `full' adds core and aux register trace.
-rtt_feature_level medium

# rtt_mux_option --- Support builds with less RTT producers than the number of cores.Currently only valid for 4:2 muxing
-rtt_mux_option false

# rtt_cti_sync --- Support CTI synchronized to ATCLK
-rtt_cti_sync false


######## Memory Protection Unit --- com.arc.hardware.HS.Memory_Protection_Unit.1_0 ########

# Create Memory Protection Unit
-create com.arc.hardware.HS.Memory_Protection_Unit.1_0 "System.Cluster.CPUisle__0.ARCv2HS.Memory Protection Unit"

# mpu_num_regions --- Number of configured memory regions.
-mpu_num_regions 8


######## Memory Management Unit --- com.arc.hardware.HS.Memory_Management_Unit.1_0 ########

# Create Memory Management Unit
-create com.arc.hardware.HS.Memory_Management_Unit.1_0 "System.Cluster.CPUisle__0.ARCv2HS.Memory Management Unit"

# mmu_ecc_option --- This specifies error checking for on-chip MMU rams.
# SECDED means single-error correction and double-error detection.
-mmu_ecc_option none

# mmu_itlb_num_entries --- This is the number of micro ITLB entries.
-mmu_itlb_num_entries 4

# mmu_dtlb_num_entries --- This is the number of micro DTLB entries.
-mmu_dtlb_num_entries 8

# mmu_ntlb_num_entries --- This is the number of joint TLB normal page entries.
-mmu_ntlb_num_entries 1024

# mmu_page_size_sel0 --- This is the page size of each joint TLB normal page.
-mmu_page_size_sel0 8K

# mmu_stlb_num_entries --- This is the number of joint TLB super page entries.
-mmu_stlb_num_entries 16

# mmu_page_size_sel1 --- This is the page size of each joint TLB super page.
-mmu_page_size_sel1 2M

# mmu_pae_enabled --- If enabled, PAE provides for a 40-bit physical memory address.
-mmu_pae_enabled true

# mmu_shared_lib --- If enabled, the shared-library ASID feature is supported.
-mmu_shared_lib true


######## Performance Monitor --- com.arc.hardware.HS.Performance_Monitor.1_0 ########

# Create Performance Monitor
-create com.arc.hardware.HS.Performance_Monitor.1_0 "System.Cluster.CPUisle__0.ARCv2HS.Performance Monitor"

# pct_counters --- Number of counters for performance monitoring.
-pct_counters 8

# pct_interrupt --- When a counter overflows, an interrupt is generated.
-pct_interrupt true


######## CPUisle__1 --- com.arc.hardware.HS.CPU_isle.1_0 ########

# Create CPUisle__1
-create com.arc.hardware.HS.CPU_isle.1_0 System.Cluster.CPUisle__1

# unique_name --- verilog module modifier prefix
-unique_name c1

# ArcNum --- The processor number as read back in the ARCNUM field of the IDENTITY register.
-arc_num 1

# instances --- 
# The number of instantiations of this core.
# 
-instances 1

# instance_signal_prefix --- 
# [arc_dev] Specifies the prefix used for each instance, when multiple instances are created.  If N is in the text, N is replaced by the instance number; otherwise the instance number is appended.
# 
-instance_signal_prefix c

# skip_vpp --- 
# This is a secret option, not seen by customers.
# If you check this, we won't VPP most of the *.vpp files.
# This can speed up re-build if you've already built them and not
# changed the core options.
# Use at your own risk.
# 	
-skip_vpp false

# OPTION_remove_tmpdir --- 
# This is a secret option, not seen by customers.
# If you uncheck this, we'll leave in place the temporary directory in which RTL is generated to support unique_name.
# 	
-remove_tmpdir true

# CPUFloorplan --- Floorplan giving relative placement of the RAMs  for the given configuration of ARCv2HS or ARCv2EM in this CPUisle
-cpu_floorplan User

# userCPUFloorplanPath --- Pathname of user floorplan for the CPU when using a hierarchical implementation
-usercpufloorplan_path /slowfs/de02dwt2p038/Gen2_libs/arc/iplib/RDF/floorplans/arc_hs38x4_alb_cpu_top_floorplan.tcl

# pinLocationConstraintsFile --- Pathname+filename of the physical pin location constraints file or just "side1" (all pins on l.h.s) or "side2" (pins on top only) or "side3" (pins on r.h.s. only) or "side4" (pins on bottom only) to get a template file generated
-pin_location_constraints_file /slowfs/de02dwt2p038/Gen2_libs/arc/iplib/RDF/floorplans/arc_hs38x4_alb_cpu_top_pin_location_constraints.tcl


######## ARCv2HS --- com.arc.hardware.HS.ARCv2HS.1_0 ########

# Create ARCv2HS
-create com.arc.hardware.HS.ARCv2HS.1_0 System.Cluster.CPUisle__1.ARCv2HS

# halt_on_reset --- This defines whether the core is halted initially on reset.
-halt_on_reset true

# byte_order --- This defines the endianness of the core.
-byte_order little

# atomic_option --- This option enables the LLOCK/SCOND (and LLOCKD/SCONDD if ll64_option) instructions
-atomic_option true

# div_rem_option --- The DIV/REM option adds non-blocking multi-cycle implementation of integer divide/remainder functions. Added instructions are DIV, DIVU (integer divide), REM and REMU (integer divide remainder).radix4_enhanced takes 3 to 19 cycles per operation.
-div_rem_option none

# mpy_option --- The Multiplier ISA option allows selection between several multiplier configurations to tradeoff performance with silicon area. Cycle count for all multiply options is fixed:  4 clocks latency with sustained throughput of 1 clock per instruction, including back-to-back multiply-accumulate operations.
# Note that some vector-add/sub operations are included with certain multiply options, in order to enhance performance of light DSP code.
# <pre>
# 
# 
#  option         Instructions
#  ----------     -------------------------------
#       
#  none                       None 
#  mpy                        MPYW/U, MPY/U, MPYH/U
#  plus_dmpy      mpy       + DMACH, DMPYH, MAC, 
#                             VADD2H,..
#  plus_macd      plus_dmpy + MACD, MPYD, 
#                             VMPY2H,...
#  plus_qmacw     plus_macd + DMACWH, DMPYWH,
#                             QMACH, QMPYH,
#                             VADD2,...
# </pre>
# 
-mpy_option none

# stack_checking --- Stack checking is a mechanism for checking stack accesses and raising an exception when a stack overflow or underflow is detected.
-stack_checking true

# ll64_option --- This enables support for Load and Store instructions that transfer register pairs to/from memory.
-ll64_option true

# intvbase_preset --- This sets the upper 22 bits of the interrupt vector base configuration register, VECBASE_AC_BUILD.  On reset, that register is loaded into the interrupt vector base address register, INT_VECTOR_BASE.  Because this value is the upper 22 bits, the vector base is aligned to a 1K-byte boundary.
-intvbase_preset 0x0

# intvbase_ext --- Set this option to drive the upper 22 bits of the interrupt base vector externally, using signal intvbase_in.
-intvbase_ext false

# nmi_option --- Set this option to enable non-maskable interrupt. 
-nmi_option false

# rgf_num_regs --- This defines the size (in 32b registers) of the processor register file.
-rgf_num_regs 32

# rgf_num_banks --- two or more register banks are useful when Fast IRQ option is selected, but multiple banks may be selected even without Fast IRQ.
-rgf_num_banks 2

# infer_alu_adder --- infer: datapath is described as behavioral code: A + B
# instantiate: datapath is instantiated as a detailed multi-stage code of a carry-lookahead adder.  It is generally preferable to use the infer option when using DesignWare library components and add directives for your target synthesizer.
-infer_alu_adder instantiate

# infer_mpy_wtree --- infer: datapath is described as behavioral code: A * B
# instantiate: datapath is instantiated as a detailed multi-stage code of a Wallace Tree multiplier.   It is preferable  to use the instantiate option; the infer option is intended for simulation only.
-infer_mpy_wtree instantiate

# aux_volatile_base --- Sets the initial base memory region (inclusive) assignment for volatile system memory
-aux_volatile_base 15

# aux_volatile_limit --- Sets the initial upper limit (exclusive) memory region assignment for volatile system memory
-aux_volatile_limit 0

# aux_volatile_disable --- Sets the initial value of Disable Volatile Region bit (on reset)
-aux_volatile_disable false

# aux_volatile_strict_ordering --- Sets the initial value of Strict Ordering bit for the volatile region (on reset)
-aux_volatile_strict_ordering true

# bist_option --- MMB bus on cpu port and accessibility of memories through MMB bus for BIST.
-bist_option false

# scantest_ram_bypass_mux --- This mux is used to make logic trapped between flops and memory (aka shadow logic) to be covered by scantest without requiring advanced sequential ATPG on the memory to be applied. Will add delay to functional access time
-scantest_ram_bypass_mux false

# power_domains --- Add power domains and propagates power-gate control signals to the top level. Also generates UPF constraints and commands in the low-power scripts
-power_domains true

# isolate_has_cdc --- Add 2 flip-flop synchronization registers for isolation signals when they are crossed different clock domain
-isolate_has_cdc false

# pd1_clk_gate_ctrl --- provide an input port to gated/ungated PD1 domain clock
-pd1_clk_gate_ctrl false

# pwr_up_on_int --- Place interrupt and timer logic in core's always-on power domain to support wake-up on interrupt or timer expiry
-pwr_up_on_int false

# dvfs --- Add logics to allow dynamic controlling of voltage and frequency and propagates the associated control signals to the top level
-dvfs true

# clock_gating --- This enables the insertion of architectural clock gate elements in the design. By enabling this option, the clocks to various parts of the design will be disabled when the logic they drive is not in use to save power.
-clock_gating true

# cpu_top_add_ppb_dccm_dmi --- Add a pipeline stage for DCCM DMI. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_dccm_dmi false

# cpu_top_add_ppb_lqwq_mem --- Add a pipeline stage for LQWQ MEM. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_lqwq_mem false

# cpu_top_add_ppb_lqwq_per0 --- Add a pipeline stage for LQWQ PER0. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_lqwq_per0 false

# cpu_top_add_ppb_lqwq_per1 --- Add a pipeline stage for LQWQ PER1. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_lqwq_per1 false

# cpu_top_add_ppb_dcache_rf --- Add a pipeline stage for DCACHE RF. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_dcache_rf false

# cpu_top_add_ppb_dcache_cb --- Add a pipeline stage for DCACHE CB. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_dcache_cb false

# cpu_top_add_ppb_iccm0_dmi --- Add a pipeline stage for ICCM0 DMI. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_iccm0_dmi false

# cpu_top_add_ppb_iccm1_dmi --- Add a pipeline stage for ICCM1 DMI. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_iccm1_dmi false

# cpu_top_add_ppb_icache_rf --- Add a pipeline stage for ICACHE RF. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_icache_rf false

# has_biu --- Use internal BIU instead of the cluster BIU. 
-has_biu false

# br_bc_entries --- The number of entries in the branch cache of the branch prediction unit. An entry can store information about 2 branch or jump instructions. More entries means that the branch predictor can keep track of more branch instructions at the same time.
-br_bc_entries 2048

# br_pt_entries --- The number of 2-bit predictors in the branch prediction unit to predict the direction (taken or not taken) of conditional branches. The prediction algorithm is Gshare. More entries means more bits of global branch history can be tracked for more branch or jump instructions at the same time.
-br_pt_entries 16384

# br_rs_entries --- The number of entries in the return address stack of the branch prediction unit. For subroutine calls and returns the return address is predicted using this stack. More entries means deeper subroutine nesting levels can be predicted accurately.
-br_rs_entries 8

# br_bc_full_tag --- The size of the tag used in the branch cache of the branch prediction unit. A full size tag avoids aliasing of branches in the branch cache, but is more costly in hardware.
-br_bc_full_tag true

# br_bc_tag_size --- If a partial tag is used, this option sets the size of that tag. The chance of aliasing declines exponentially with the size of the tag and in a lot of applications a small tag works fine.
-br_bc_tag_size 4

# br_tosq_entries --- The Top-Of-Stack queue keeps track of subroutine calls and returns that are in progress at the same time in the processor. A small number saves hardware, a large number gives highest performance even when there are dense subroutine call and return patterns.
-br_tosq_entries 8

# br_fb_entries --- The size of the instruction buffer that stores instructions that have been fetched but not yet executed in the processor. A larger buffer allows better performance on complex branch and jump patterns at the expense of hardware.
-br_fb_entries 4

# lpb_num --- 0 indicates no loop buffer configured. This specifies the size of loop buffer.A larger buffer number allows better power saving on longer loop at the expense of hardwareFor instruction lp, lpcc, dbnz, access from loop buffer instead of icache, iccm, external bus and bpu.After detection of the loop, capture these instructions of the loop in the loop buffer.These instructions will be sent to fetch buffer
-lpb_num 8

# grad_entries --- Graduation entries track post-commit instructions awaiting result retirement. For example, long non-blocking instructions such as divide or certain deeply pipelined APEX instructions.
-grad_entries 8

# uaux_option --- Include a user auxiliary register interface
-uaux_option false


######## AGU --- com.arc.hardware.HS.AGU.1_0 ########

# Create AGU
-create com.arc.hardware.HS.AGU.1_0 System.Cluster.CPUisle__1.ARCv2HS.AGU

######## ARCHS_dual_issue --- com.arc.hardware.HS.ARCHS_dual_issue.1_0 ########

# Create ARCHS_dual_issue
-create com.arc.hardware.HS.ARCHS_dual_issue.1_0 System.Cluster.CPUisle__1.ARCv2HS.ARCHS_dual_issue

######## DSP --- com.arc.hardware.HS.DSP.1_0 ########

# Create DSP
-create com.arc.hardware.HS.DSP.1_0 System.Cluster.CPUisle__1.ARCv2HS.DSP

# dsp_itu --- Enable/disable support for ITU bit-accurate 1 bit fractional shift before accumulation, else 1-bit fractional shift result after accumulation only
-dsp_itu true

# dsp_divsqrt --- Enable/disable support for divide and square root operations: DIV(U)(F), REM(U), SQRT(F)
-dsp_divsqrt radix4

# dsp_wide --- Enable/disable support for 4x16x16 and 2x32x16 MAC instructions
-dsp_wide true

# dsp_impl --- The datapath components may be inferred from Verilog for better area or optimized using carry-save components for better timing
-dsp_impl optimized


######## FastMath --- com.arc.hardware.FastMath.1_0 ########

# Create FastMath
-create com.arc.hardware.FastMath.1_0 System.Cluster.CPUisle__1.ARCv2HS.FastMath

# FastMath --- Command line option for EIA extension component 'FastMath'.
-fastmath ""

# support_div --- Include recip & div inst
-support_div true

# support_sqrt --- Include sqrt inst
-support_sqrt true

# support_sat --- Include sath rndh & adds inst
-support_sat true

# support_trig --- Include trig log2 & exp2 inst
-support_trig true


######## Floating-point unit --- com.arc.hardware.HS.Floating_point_unit.1_0 ########

# Create Floating-point unit
-create com.arc.hardware.HS.Floating_point_unit.1_0 "System.Cluster.CPUisle__1.ARCv2HS.Floating-point unit"

# fpu_dp_option --- This enables double-precision floating point instructions.
-fpu_dp_option true

# fpu_div_option --- This enables divide & square-root instructions
-fpu_div_option true

# fpu_fma_option --- This enables the multiply & accumulate instructions.
-fpu_fma_option true


######## Interrupt Controller --- com.arc.hardware.HS.Interrupt_Controller.1_0 ########

# Create Interrupt Controller
-create com.arc.hardware.HS.Interrupt_Controller.1_0 "System.Cluster.CPUisle__1.ARCv2HS.Interrupt Controller"

# number_of_interrupts --- This is the total number of interrupts available to the core.  Some interrupts are allocated statically to a specific interrupt line (for example, timer interrupts).  For more information on Interrupt and register-file options, see DesignWare ARCv2 ISA Programmers Reference Manual.
-number_of_interrupts 73

# number_of_levels --- Priority levels in the interrupt controller.
-number_of_levels 2

# external_interrupts --- This is the total number of interrupt pins available for external system components.  This parameter must be less than the total number of interrupts.
-external_interrupts 70

# firq_option --- This enables the fast-interrupts option, (priority level 0 interrupts), which uses an alternate register bank (if configured) instead of saving the context to memory.
-firq_option true


######## Real-time Counter --- com.arc.hardware.HS.Real_time_Counter.1_0 ########

# Create Real-time Counter
-create com.arc.hardware.HS.Real_time_Counter.1_0 "System.Cluster.CPUisle__1.ARCv2HS.Real-time Counter"

######## Timer 0 --- com.arc.hardware.HS.Timer_0.1_0 ########

# Create Timer 0
-create com.arc.hardware.HS.Timer_0.1_0 "System.Cluster.CPUisle__1.ARCv2HS.Timer 0"

# timer_0_int_level --- This sets the interrupt level (and implicitly the priority: level 0 is highest) of timer 0.
-timer_0_int_level 1


######## Timer 1 --- com.arc.hardware.HS.Timer_1.1_0 ########

# Create Timer 1
-create com.arc.hardware.HS.Timer_1.1_0 "System.Cluster.CPUisle__1.ARCv2HS.Timer 1"

# timer_1_int_level --- This sets the interrupt level (and implicitly the priority: level 0 is highest) of timer 1.
-timer_1_int_level 0


######## DCCM --- com.arc.hardware.HS.DCCM.1_0 ########

# Create DCCM
-create com.arc.hardware.HS.DCCM.1_0 System.Cluster.CPUisle__1.ARCv2HS.DCCM

# dccm_size --- This defines the size of the Data Closely Coupled Memory (DCCM) in bytes
-dccm_size 65536

# dccm_base --- Sets the initial memory region assignment for DCCM base address
-dccm_base 6

# dccm_dmi --- This enables external access through a DMI (direct memory interface) port.
-dccm_dmi true

# dccm_dmi_partial_ecc --- This enables the partial write support through a DMI (direct memory interface) port.
-dccm_dmi_partial_ecc false

# dccm_mem_cycles --- This defines the number of cycles dedicated to the each DCCM Memory bank.
-dccm_mem_cycles 2

# dccm_mem_posedge --- This option clocks the DCCM memory banks on the positive edge of the clock
-dccm_mem_posedge false

# dccm_mem_banks --- This option selects the number of DCCM memory banks
-dccm_mem_banks 4

# dccm_ecc_option --- This specifies error checking for on-chip DCCM rams.
# SECDED means single-error correction and double-error detection.
-dccm_ecc_option none


######## Data Cache --- com.arc.hardware.HS.Data_Cache.1_0 ########

# Create Data Cache
-create com.arc.hardware.HS.Data_Cache.1_0 "System.Cluster.CPUisle__1.ARCv2HS.Data Cache"

# dc_size --- This defines the total size of the Data Cache in bytes.
-dc_size 65536

# dc_bsize --- This defines the cache line length in bytes.
-dc_bsize 64

# dc_bus_data_width --- This defines the cache bus width for refills and evictions.
-dc_bus_data_width 64

# dc_mem_cycles --- This defines the number of cycles dedicated to the Data Cache data memories.
-dc_mem_cycles 2

# dc_mem_posedge --- This option clocks the Data Cache memories on the positive edge of the clock
-dc_mem_posedge false

# dc_ecc_option --- This specifies error checking for DCACHE Tag, Data rams.
# SECDED means single-error correction and double-error detection.
-dc_ecc_option none


######## ICCM0 --- com.arc.hardware.HS.ICCM0.1_0 ########

# Create ICCM0
-create com.arc.hardware.HS.ICCM0.1_0 System.Cluster.CPUisle__1.ARCv2HS.ICCM0

# iccm0_size --- This defines the size of ICCM0 in bytes.This ICCM has 0 wait states.
-iccm0_size 262144

# iccm0_base --- Sets the initial memory region assignment for ICCM0
-iccm0_base 6

# iccm0_dmi --- This enables external access through a DMI (direct memory interface) port.
-iccm0_dmi true

# iccm0_ecc_option --- This specifies error checking for on-chip ICCM0
-iccm0_ecc_option none


######## Instruction Cache --- com.arc.hardware.HS.Instruction_Cache.1_0 ########

# Create Instruction Cache
-create com.arc.hardware.HS.Instruction_Cache.1_0 "System.Cluster.CPUisle__1.ARCv2HS.Instruction Cache"

# ic_size --- This defines the total size of the instruction cache in bytes.
-ic_size 65536

# ic_ways --- This defines the number of cache ways
-ic_ways 4

# ic_bsize --- This defines the cache line length in bytes.
-ic_bsize 64

# ic_disable_on_reset --- The instruction cache may be enabled immediately after reset, depending on this option.  If this option is set to true, the instruction cache is disabled and instruction fetches bypass the cache, accessing system memory directly.
-ic_disable_on_reset false

# ic_pipeline_bus --- This option inserts a pipeline register on the instruction cache's refill bus from memory. This option can be used to ease timing in configurations where cores are not closely located with level-2 cache, for example.
-ic_pipeline_bus true

# ic_ecc_option --- This specifies error checking for ICACHE Tag, Data rams.
# SECDED means single-error correction and double-error detection.
-ic_ecc_option none


######## JTAG Interface --- com.arc.hardware.HS.JTAG_Interface.1_0 ########

# Create JTAG Interface
-create com.arc.hardware.HS.JTAG_Interface.1_0 "System.Cluster.CPUisle__1.ARCv2HS.JTAG Interface"

######## Debug Interface --- com.arc.hardware.HS.Debug_Interface.1_0 ########

# Create Debug Interface
-create com.arc.hardware.HS.Debug_Interface.1_0 "System.Cluster.CPUisle__1.ARCv2HS.Debug Interface"

# dbg_en_option --- Adds an enable pin to the existing debug interface
-dbg_en_option false

# dbg_apb_option --- Adds an additional APB debug port alongside the BVCI one
-dbg_apb_option false

# dbg_apb_ratio --- Sets the clock ratio for the APB debug port to core clock
-dbg_apb_ratio 12


######## Actionpoints --- com.arc.hardware.HS.Actionpoints.1_0 ########

# Create Actionpoints
-create com.arc.hardware.HS.Actionpoints.1_0 System.Cluster.CPUisle__1.ARCv2HS.Actionpoints

# num_actionpoints --- This is the number of trigger events available.
-num_actionpoints 8

# aps_feature --- Selects Actionpoint feature set
-aps_feature full


######## SmaRT --- com.arc.hardware.HS.SmaRT.1_0 ########

# Create SmaRT
-create com.arc.hardware.HS.SmaRT.1_0 System.Cluster.CPUisle__1.ARCv2HS.SmaRT

# smart_stack_entries --- This specifies the number of entries in the trace buffer.
-smart_stack_entries 64

# smart_implementation --- Flip-flop = FF-based design.  Memory = memory-based design (provides better density for larger trace buffers).
-smart_implementation memory


######## Real-time trace producer --- com.arc.hardware.HS.Real_time_trace_producer.1_0 ########

# Create Real-time trace producer
-create com.arc.hardware.HS.Real_time_trace_producer.1_0 "System.Cluster.CPUisle__1.ARCv2HS.Real-time trace producer"

# rtt_feature_level --- 'small' means that program trace only is available.  `medium' adds data trace.  `full' adds core and aux register trace.
-rtt_feature_level medium

# rtt_mux_option --- Support builds with less RTT producers than the number of cores.Currently only valid for 4:2 muxing
-rtt_mux_option false

# rtt_cti_sync --- Support CTI synchronized to ATCLK
-rtt_cti_sync false


######## Memory Protection Unit --- com.arc.hardware.HS.Memory_Protection_Unit.1_0 ########

# Create Memory Protection Unit
-create com.arc.hardware.HS.Memory_Protection_Unit.1_0 "System.Cluster.CPUisle__1.ARCv2HS.Memory Protection Unit"

# mpu_num_regions --- Number of configured memory regions.
-mpu_num_regions 8


######## Memory Management Unit --- com.arc.hardware.HS.Memory_Management_Unit.1_0 ########

# Create Memory Management Unit
-create com.arc.hardware.HS.Memory_Management_Unit.1_0 "System.Cluster.CPUisle__1.ARCv2HS.Memory Management Unit"

# mmu_ecc_option --- This specifies error checking for on-chip MMU rams.
# SECDED means single-error correction and double-error detection.
-mmu_ecc_option none

# mmu_itlb_num_entries --- This is the number of micro ITLB entries.
-mmu_itlb_num_entries 4

# mmu_dtlb_num_entries --- This is the number of micro DTLB entries.
-mmu_dtlb_num_entries 8

# mmu_ntlb_num_entries --- This is the number of joint TLB normal page entries.
-mmu_ntlb_num_entries 1024

# mmu_page_size_sel0 --- This is the page size of each joint TLB normal page.
-mmu_page_size_sel0 8K

# mmu_stlb_num_entries --- This is the number of joint TLB super page entries.
-mmu_stlb_num_entries 16

# mmu_page_size_sel1 --- This is the page size of each joint TLB super page.
-mmu_page_size_sel1 2M

# mmu_pae_enabled --- If enabled, PAE provides for a 40-bit physical memory address.
-mmu_pae_enabled true

# mmu_shared_lib --- If enabled, the shared-library ASID feature is supported.
-mmu_shared_lib true


######## Performance Monitor --- com.arc.hardware.HS.Performance_Monitor.1_0 ########

# Create Performance Monitor
-create com.arc.hardware.HS.Performance_Monitor.1_0 "System.Cluster.CPUisle__1.ARCv2HS.Performance Monitor"

# pct_counters --- Number of counters for performance monitoring.
-pct_counters 8

# pct_interrupt --- When a counter overflows, an interrupt is generated.
-pct_interrupt true


######## CPUisle__2 --- com.arc.hardware.HS.CPU_isle.1_0 ########

# Create CPUisle__2
-create com.arc.hardware.HS.CPU_isle.1_0 System.Cluster.CPUisle__2

# unique_name --- verilog module modifier prefix
-unique_name c2

# ArcNum --- The processor number as read back in the ARCNUM field of the IDENTITY register.
-arc_num 2

# instances --- 
# The number of instantiations of this core.
# 
-instances 1

# instance_signal_prefix --- 
# [arc_dev] Specifies the prefix used for each instance, when multiple instances are created.  If N is in the text, N is replaced by the instance number; otherwise the instance number is appended.
# 
-instance_signal_prefix c

# skip_vpp --- 
# This is a secret option, not seen by customers.
# If you check this, we won't VPP most of the *.vpp files.
# This can speed up re-build if you've already built them and not
# changed the core options.
# Use at your own risk.
# 	
-skip_vpp false

# OPTION_remove_tmpdir --- 
# This is a secret option, not seen by customers.
# If you uncheck this, we'll leave in place the temporary directory in which RTL is generated to support unique_name.
# 	
-remove_tmpdir true

# CPUFloorplan --- Floorplan giving relative placement of the RAMs  for the given configuration of ARCv2HS or ARCv2EM in this CPUisle
-cpu_floorplan User

# userCPUFloorplanPath --- Pathname of user floorplan for the CPU when using a hierarchical implementation
-usercpufloorplan_path /slowfs/de02dwt2p038/Gen2_libs/arc/iplib/RDF/floorplans/arc_hs38x4_alb_cpu_top_floorplan.tcl

# pinLocationConstraintsFile --- Pathname+filename of the physical pin location constraints file or just "side1" (all pins on l.h.s) or "side2" (pins on top only) or "side3" (pins on r.h.s. only) or "side4" (pins on bottom only) to get a template file generated
-pin_location_constraints_file /slowfs/de02dwt2p038/Gen2_libs/arc/iplib/RDF/floorplans/arc_hs38x4_alb_cpu_top_pin_location_constraints.tcl


######## ARCv2HS --- com.arc.hardware.HS.ARCv2HS.1_0 ########

# Create ARCv2HS
-create com.arc.hardware.HS.ARCv2HS.1_0 System.Cluster.CPUisle__2.ARCv2HS

# halt_on_reset --- This defines whether the core is halted initially on reset.
-halt_on_reset true

# byte_order --- This defines the endianness of the core.
-byte_order little

# atomic_option --- This option enables the LLOCK/SCOND (and LLOCKD/SCONDD if ll64_option) instructions
-atomic_option true

# div_rem_option --- The DIV/REM option adds non-blocking multi-cycle implementation of integer divide/remainder functions. Added instructions are DIV, DIVU (integer divide), REM and REMU (integer divide remainder).radix4_enhanced takes 3 to 19 cycles per operation.
-div_rem_option none

# mpy_option --- The Multiplier ISA option allows selection between several multiplier configurations to tradeoff performance with silicon area. Cycle count for all multiply options is fixed:  4 clocks latency with sustained throughput of 1 clock per instruction, including back-to-back multiply-accumulate operations.
# Note that some vector-add/sub operations are included with certain multiply options, in order to enhance performance of light DSP code.
# <pre>
# 
# 
#  option         Instructions
#  ----------     -------------------------------
#       
#  none                       None 
#  mpy                        MPYW/U, MPY/U, MPYH/U
#  plus_dmpy      mpy       + DMACH, DMPYH, MAC, 
#                             VADD2H,..
#  plus_macd      plus_dmpy + MACD, MPYD, 
#                             VMPY2H,...
#  plus_qmacw     plus_macd + DMACWH, DMPYWH,
#                             QMACH, QMPYH,
#                             VADD2,...
# </pre>
# 
-mpy_option none

# stack_checking --- Stack checking is a mechanism for checking stack accesses and raising an exception when a stack overflow or underflow is detected.
-stack_checking true

# ll64_option --- This enables support for Load and Store instructions that transfer register pairs to/from memory.
-ll64_option true

# intvbase_preset --- This sets the upper 22 bits of the interrupt vector base configuration register, VECBASE_AC_BUILD.  On reset, that register is loaded into the interrupt vector base address register, INT_VECTOR_BASE.  Because this value is the upper 22 bits, the vector base is aligned to a 1K-byte boundary.
-intvbase_preset 0x0

# intvbase_ext --- Set this option to drive the upper 22 bits of the interrupt base vector externally, using signal intvbase_in.
-intvbase_ext false

# nmi_option --- Set this option to enable non-maskable interrupt. 
-nmi_option false

# rgf_num_regs --- This defines the size (in 32b registers) of the processor register file.
-rgf_num_regs 32

# rgf_num_banks --- two or more register banks are useful when Fast IRQ option is selected, but multiple banks may be selected even without Fast IRQ.
-rgf_num_banks 2

# infer_alu_adder --- infer: datapath is described as behavioral code: A + B
# instantiate: datapath is instantiated as a detailed multi-stage code of a carry-lookahead adder.  It is generally preferable to use the infer option when using DesignWare library components and add directives for your target synthesizer.
-infer_alu_adder instantiate

# infer_mpy_wtree --- infer: datapath is described as behavioral code: A * B
# instantiate: datapath is instantiated as a detailed multi-stage code of a Wallace Tree multiplier.   It is preferable  to use the instantiate option; the infer option is intended for simulation only.
-infer_mpy_wtree instantiate

# aux_volatile_base --- Sets the initial base memory region (inclusive) assignment for volatile system memory
-aux_volatile_base 15

# aux_volatile_limit --- Sets the initial upper limit (exclusive) memory region assignment for volatile system memory
-aux_volatile_limit 0

# aux_volatile_disable --- Sets the initial value of Disable Volatile Region bit (on reset)
-aux_volatile_disable false

# aux_volatile_strict_ordering --- Sets the initial value of Strict Ordering bit for the volatile region (on reset)
-aux_volatile_strict_ordering true

# bist_option --- MMB bus on cpu port and accessibility of memories through MMB bus for BIST.
-bist_option false

# scantest_ram_bypass_mux --- This mux is used to make logic trapped between flops and memory (aka shadow logic) to be covered by scantest without requiring advanced sequential ATPG on the memory to be applied. Will add delay to functional access time
-scantest_ram_bypass_mux false

# power_domains --- Add power domains and propagates power-gate control signals to the top level. Also generates UPF constraints and commands in the low-power scripts
-power_domains true

# isolate_has_cdc --- Add 2 flip-flop synchronization registers for isolation signals when they are crossed different clock domain
-isolate_has_cdc false

# pd1_clk_gate_ctrl --- provide an input port to gated/ungated PD1 domain clock
-pd1_clk_gate_ctrl false

# pwr_up_on_int --- Place interrupt and timer logic in core's always-on power domain to support wake-up on interrupt or timer expiry
-pwr_up_on_int false

# dvfs --- Add logics to allow dynamic controlling of voltage and frequency and propagates the associated control signals to the top level
-dvfs true

# clock_gating --- This enables the insertion of architectural clock gate elements in the design. By enabling this option, the clocks to various parts of the design will be disabled when the logic they drive is not in use to save power.
-clock_gating true

# cpu_top_add_ppb_dccm_dmi --- Add a pipeline stage for DCCM DMI. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_dccm_dmi false

# cpu_top_add_ppb_lqwq_mem --- Add a pipeline stage for LQWQ MEM. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_lqwq_mem false

# cpu_top_add_ppb_lqwq_per0 --- Add a pipeline stage for LQWQ PER0. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_lqwq_per0 false

# cpu_top_add_ppb_lqwq_per1 --- Add a pipeline stage for LQWQ PER1. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_lqwq_per1 false

# cpu_top_add_ppb_dcache_rf --- Add a pipeline stage for DCACHE RF. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_dcache_rf false

# cpu_top_add_ppb_dcache_cb --- Add a pipeline stage for DCACHE CB. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_dcache_cb false

# cpu_top_add_ppb_iccm0_dmi --- Add a pipeline stage for ICCM0 DMI. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_iccm0_dmi false

# cpu_top_add_ppb_iccm1_dmi --- Add a pipeline stage for ICCM1 DMI. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_iccm1_dmi false

# cpu_top_add_ppb_icache_rf --- Add a pipeline stage for ICACHE RF. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_icache_rf false

# has_biu --- Use internal BIU instead of the cluster BIU. 
-has_biu false

# br_bc_entries --- The number of entries in the branch cache of the branch prediction unit. An entry can store information about 2 branch or jump instructions. More entries means that the branch predictor can keep track of more branch instructions at the same time.
-br_bc_entries 2048

# br_pt_entries --- The number of 2-bit predictors in the branch prediction unit to predict the direction (taken or not taken) of conditional branches. The prediction algorithm is Gshare. More entries means more bits of global branch history can be tracked for more branch or jump instructions at the same time.
-br_pt_entries 16384

# br_rs_entries --- The number of entries in the return address stack of the branch prediction unit. For subroutine calls and returns the return address is predicted using this stack. More entries means deeper subroutine nesting levels can be predicted accurately.
-br_rs_entries 8

# br_bc_full_tag --- The size of the tag used in the branch cache of the branch prediction unit. A full size tag avoids aliasing of branches in the branch cache, but is more costly in hardware.
-br_bc_full_tag true

# br_bc_tag_size --- If a partial tag is used, this option sets the size of that tag. The chance of aliasing declines exponentially with the size of the tag and in a lot of applications a small tag works fine.
-br_bc_tag_size 4

# br_tosq_entries --- The Top-Of-Stack queue keeps track of subroutine calls and returns that are in progress at the same time in the processor. A small number saves hardware, a large number gives highest performance even when there are dense subroutine call and return patterns.
-br_tosq_entries 8

# br_fb_entries --- The size of the instruction buffer that stores instructions that have been fetched but not yet executed in the processor. A larger buffer allows better performance on complex branch and jump patterns at the expense of hardware.
-br_fb_entries 4

# lpb_num --- 0 indicates no loop buffer configured. This specifies the size of loop buffer.A larger buffer number allows better power saving on longer loop at the expense of hardwareFor instruction lp, lpcc, dbnz, access from loop buffer instead of icache, iccm, external bus and bpu.After detection of the loop, capture these instructions of the loop in the loop buffer.These instructions will be sent to fetch buffer
-lpb_num 8

# grad_entries --- Graduation entries track post-commit instructions awaiting result retirement. For example, long non-blocking instructions such as divide or certain deeply pipelined APEX instructions.
-grad_entries 8

# uaux_option --- Include a user auxiliary register interface
-uaux_option false


######## AGU --- com.arc.hardware.HS.AGU.1_0 ########

# Create AGU
-create com.arc.hardware.HS.AGU.1_0 System.Cluster.CPUisle__2.ARCv2HS.AGU

######## ARCHS_dual_issue --- com.arc.hardware.HS.ARCHS_dual_issue.1_0 ########

# Create ARCHS_dual_issue
-create com.arc.hardware.HS.ARCHS_dual_issue.1_0 System.Cluster.CPUisle__2.ARCv2HS.ARCHS_dual_issue

######## DSP --- com.arc.hardware.HS.DSP.1_0 ########

# Create DSP
-create com.arc.hardware.HS.DSP.1_0 System.Cluster.CPUisle__2.ARCv2HS.DSP

# dsp_itu --- Enable/disable support for ITU bit-accurate 1 bit fractional shift before accumulation, else 1-bit fractional shift result after accumulation only
-dsp_itu true

# dsp_divsqrt --- Enable/disable support for divide and square root operations: DIV(U)(F), REM(U), SQRT(F)
-dsp_divsqrt radix4

# dsp_wide --- Enable/disable support for 4x16x16 and 2x32x16 MAC instructions
-dsp_wide true

# dsp_impl --- The datapath components may be inferred from Verilog for better area or optimized using carry-save components for better timing
-dsp_impl optimized


######## FastMath --- com.arc.hardware.FastMath.1_0 ########

# Create FastMath
-create com.arc.hardware.FastMath.1_0 System.Cluster.CPUisle__2.ARCv2HS.FastMath

# FastMath --- Command line option for EIA extension component 'FastMath'.
-fastmath ""

# support_div --- Include recip & div inst
-support_div true

# support_sqrt --- Include sqrt inst
-support_sqrt true

# support_sat --- Include sath rndh & adds inst
-support_sat true

# support_trig --- Include trig log2 & exp2 inst
-support_trig true


######## Floating-point unit --- com.arc.hardware.HS.Floating_point_unit.1_0 ########

# Create Floating-point unit
-create com.arc.hardware.HS.Floating_point_unit.1_0 "System.Cluster.CPUisle__2.ARCv2HS.Floating-point unit"

# fpu_dp_option --- This enables double-precision floating point instructions.
-fpu_dp_option true

# fpu_div_option --- This enables divide & square-root instructions
-fpu_div_option true

# fpu_fma_option --- This enables the multiply & accumulate instructions.
-fpu_fma_option true


######## Interrupt Controller --- com.arc.hardware.HS.Interrupt_Controller.1_0 ########

# Create Interrupt Controller
-create com.arc.hardware.HS.Interrupt_Controller.1_0 "System.Cluster.CPUisle__2.ARCv2HS.Interrupt Controller"

# number_of_interrupts --- This is the total number of interrupts available to the core.  Some interrupts are allocated statically to a specific interrupt line (for example, timer interrupts).  For more information on Interrupt and register-file options, see DesignWare ARCv2 ISA Programmers Reference Manual.
-number_of_interrupts 73

# number_of_levels --- Priority levels in the interrupt controller.
-number_of_levels 2

# external_interrupts --- This is the total number of interrupt pins available for external system components.  This parameter must be less than the total number of interrupts.
-external_interrupts 70

# firq_option --- This enables the fast-interrupts option, (priority level 0 interrupts), which uses an alternate register bank (if configured) instead of saving the context to memory.
-firq_option true


######## Real-time Counter --- com.arc.hardware.HS.Real_time_Counter.1_0 ########

# Create Real-time Counter
-create com.arc.hardware.HS.Real_time_Counter.1_0 "System.Cluster.CPUisle__2.ARCv2HS.Real-time Counter"

######## Timer 0 --- com.arc.hardware.HS.Timer_0.1_0 ########

# Create Timer 0
-create com.arc.hardware.HS.Timer_0.1_0 "System.Cluster.CPUisle__2.ARCv2HS.Timer 0"

# timer_0_int_level --- This sets the interrupt level (and implicitly the priority: level 0 is highest) of timer 0.
-timer_0_int_level 1


######## Timer 1 --- com.arc.hardware.HS.Timer_1.1_0 ########

# Create Timer 1
-create com.arc.hardware.HS.Timer_1.1_0 "System.Cluster.CPUisle__2.ARCv2HS.Timer 1"

# timer_1_int_level --- This sets the interrupt level (and implicitly the priority: level 0 is highest) of timer 1.
-timer_1_int_level 0


######## Data Cache --- com.arc.hardware.HS.Data_Cache.1_0 ########

# Create Data Cache
-create com.arc.hardware.HS.Data_Cache.1_0 "System.Cluster.CPUisle__2.ARCv2HS.Data Cache"

# dc_size --- This defines the total size of the Data Cache in bytes.
-dc_size 65536

# dc_bsize --- This defines the cache line length in bytes.
-dc_bsize 64

# dc_bus_data_width --- This defines the cache bus width for refills and evictions.
-dc_bus_data_width 64

# dc_mem_cycles --- This defines the number of cycles dedicated to the Data Cache data memories.
-dc_mem_cycles 2

# dc_mem_posedge --- This option clocks the Data Cache memories on the positive edge of the clock
-dc_mem_posedge false

# dc_ecc_option --- This specifies error checking for DCACHE Tag, Data rams.
# SECDED means single-error correction and double-error detection.
-dc_ecc_option none


######## Instruction Cache --- com.arc.hardware.HS.Instruction_Cache.1_0 ########

# Create Instruction Cache
-create com.arc.hardware.HS.Instruction_Cache.1_0 "System.Cluster.CPUisle__2.ARCv2HS.Instruction Cache"

# ic_size --- This defines the total size of the instruction cache in bytes.
-ic_size 65536

# ic_ways --- This defines the number of cache ways
-ic_ways 4

# ic_bsize --- This defines the cache line length in bytes.
-ic_bsize 64

# ic_disable_on_reset --- The instruction cache may be enabled immediately after reset, depending on this option.  If this option is set to true, the instruction cache is disabled and instruction fetches bypass the cache, accessing system memory directly.
-ic_disable_on_reset false

# ic_pipeline_bus --- This option inserts a pipeline register on the instruction cache's refill bus from memory. This option can be used to ease timing in configurations where cores are not closely located with level-2 cache, for example.
-ic_pipeline_bus true

# ic_ecc_option --- This specifies error checking for ICACHE Tag, Data rams.
# SECDED means single-error correction and double-error detection.
-ic_ecc_option none


######## JTAG Interface --- com.arc.hardware.HS.JTAG_Interface.1_0 ########

# Create JTAG Interface
-create com.arc.hardware.HS.JTAG_Interface.1_0 "System.Cluster.CPUisle__2.ARCv2HS.JTAG Interface"

######## Debug Interface --- com.arc.hardware.HS.Debug_Interface.1_0 ########

# Create Debug Interface
-create com.arc.hardware.HS.Debug_Interface.1_0 "System.Cluster.CPUisle__2.ARCv2HS.Debug Interface"

# dbg_en_option --- Adds an enable pin to the existing debug interface
-dbg_en_option false

# dbg_apb_option --- Adds an additional APB debug port alongside the BVCI one
-dbg_apb_option false

# dbg_apb_ratio --- Sets the clock ratio for the APB debug port to core clock
-dbg_apb_ratio 12


######## Actionpoints --- com.arc.hardware.HS.Actionpoints.1_0 ########

# Create Actionpoints
-create com.arc.hardware.HS.Actionpoints.1_0 System.Cluster.CPUisle__2.ARCv2HS.Actionpoints

# num_actionpoints --- This is the number of trigger events available.
-num_actionpoints 8

# aps_feature --- Selects Actionpoint feature set
-aps_feature full


######## SmaRT --- com.arc.hardware.HS.SmaRT.1_0 ########

# Create SmaRT
-create com.arc.hardware.HS.SmaRT.1_0 System.Cluster.CPUisle__2.ARCv2HS.SmaRT

# smart_stack_entries --- This specifies the number of entries in the trace buffer.
-smart_stack_entries 64

# smart_implementation --- Flip-flop = FF-based design.  Memory = memory-based design (provides better density for larger trace buffers).
-smart_implementation memory


######## Real-time trace producer --- com.arc.hardware.HS.Real_time_trace_producer.1_0 ########

# Create Real-time trace producer
-create com.arc.hardware.HS.Real_time_trace_producer.1_0 "System.Cluster.CPUisle__2.ARCv2HS.Real-time trace producer"

# rtt_feature_level --- 'small' means that program trace only is available.  `medium' adds data trace.  `full' adds core and aux register trace.
-rtt_feature_level medium

# rtt_mux_option --- Support builds with less RTT producers than the number of cores.Currently only valid for 4:2 muxing
-rtt_mux_option false

# rtt_cti_sync --- Support CTI synchronized to ATCLK
-rtt_cti_sync false


######## Memory Protection Unit --- com.arc.hardware.HS.Memory_Protection_Unit.1_0 ########

# Create Memory Protection Unit
-create com.arc.hardware.HS.Memory_Protection_Unit.1_0 "System.Cluster.CPUisle__2.ARCv2HS.Memory Protection Unit"

# mpu_num_regions --- Number of configured memory regions.
-mpu_num_regions 8


######## Memory Management Unit --- com.arc.hardware.HS.Memory_Management_Unit.1_0 ########

# Create Memory Management Unit
-create com.arc.hardware.HS.Memory_Management_Unit.1_0 "System.Cluster.CPUisle__2.ARCv2HS.Memory Management Unit"

# mmu_ecc_option --- This specifies error checking for on-chip MMU rams.
# SECDED means single-error correction and double-error detection.
-mmu_ecc_option none

# mmu_itlb_num_entries --- This is the number of micro ITLB entries.
-mmu_itlb_num_entries 4

# mmu_dtlb_num_entries --- This is the number of micro DTLB entries.
-mmu_dtlb_num_entries 8

# mmu_ntlb_num_entries --- This is the number of joint TLB normal page entries.
-mmu_ntlb_num_entries 1024

# mmu_page_size_sel0 --- This is the page size of each joint TLB normal page.
-mmu_page_size_sel0 8K

# mmu_stlb_num_entries --- This is the number of joint TLB super page entries.
-mmu_stlb_num_entries 16

# mmu_page_size_sel1 --- This is the page size of each joint TLB super page.
-mmu_page_size_sel1 2M

# mmu_pae_enabled --- If enabled, PAE provides for a 40-bit physical memory address.
-mmu_pae_enabled true

# mmu_shared_lib --- If enabled, the shared-library ASID feature is supported.
-mmu_shared_lib true


######## Performance Monitor --- com.arc.hardware.HS.Performance_Monitor.1_0 ########

# Create Performance Monitor
-create com.arc.hardware.HS.Performance_Monitor.1_0 "System.Cluster.CPUisle__2.ARCv2HS.Performance Monitor"

# pct_counters --- Number of counters for performance monitoring.
-pct_counters 8

# pct_interrupt --- When a counter overflows, an interrupt is generated.
-pct_interrupt true


######## CPUisle__3 --- com.arc.hardware.HS.CPU_isle.1_0 ########

# Create CPUisle__3
-create com.arc.hardware.HS.CPU_isle.1_0 System.Cluster.CPUisle__3

# unique_name --- verilog module modifier prefix
-unique_name c3

# ArcNum --- The processor number as read back in the ARCNUM field of the IDENTITY register.
-arc_num 3

# instances --- 
# The number of instantiations of this core.
# 
-instances 1

# instance_signal_prefix --- 
# [arc_dev] Specifies the prefix used for each instance, when multiple instances are created.  If N is in the text, N is replaced by the instance number; otherwise the instance number is appended.
# 
-instance_signal_prefix c

# skip_vpp --- 
# This is a secret option, not seen by customers.
# If you check this, we won't VPP most of the *.vpp files.
# This can speed up re-build if you've already built them and not
# changed the core options.
# Use at your own risk.
# 	
-skip_vpp false

# OPTION_remove_tmpdir --- 
# This is a secret option, not seen by customers.
# If you uncheck this, we'll leave in place the temporary directory in which RTL is generated to support unique_name.
# 	
-remove_tmpdir true

# CPUFloorplan --- Floorplan giving relative placement of the RAMs  for the given configuration of ARCv2HS or ARCv2EM in this CPUisle
-cpu_floorplan User

# userCPUFloorplanPath --- Pathname of user floorplan for the CPU when using a hierarchical implementation
-usercpufloorplan_path /slowfs/de02dwt2p038/Gen2_libs/arc/iplib/RDF/floorplans/arc_hs38x4_alb_cpu_top_floorplan.tcl

# pinLocationConstraintsFile --- Pathname+filename of the physical pin location constraints file or just "side1" (all pins on l.h.s) or "side2" (pins on top only) or "side3" (pins on r.h.s. only) or "side4" (pins on bottom only) to get a template file generated
-pin_location_constraints_file /slowfs/de02dwt2p038/Gen2_libs/arc/iplib/RDF/floorplans/arc_hs38x4_alb_cpu_top_pin_location_constraints.tcl


######## ARCv2HS --- com.arc.hardware.HS.ARCv2HS.1_0 ########

# Create ARCv2HS
-create com.arc.hardware.HS.ARCv2HS.1_0 System.Cluster.CPUisle__3.ARCv2HS

# halt_on_reset --- This defines whether the core is halted initially on reset.
-halt_on_reset true

# byte_order --- This defines the endianness of the core.
-byte_order little

# atomic_option --- This option enables the LLOCK/SCOND (and LLOCKD/SCONDD if ll64_option) instructions
-atomic_option true

# div_rem_option --- The DIV/REM option adds non-blocking multi-cycle implementation of integer divide/remainder functions. Added instructions are DIV, DIVU (integer divide), REM and REMU (integer divide remainder).radix4_enhanced takes 3 to 19 cycles per operation.
-div_rem_option none

# mpy_option --- The Multiplier ISA option allows selection between several multiplier configurations to tradeoff performance with silicon area. Cycle count for all multiply options is fixed:  4 clocks latency with sustained throughput of 1 clock per instruction, including back-to-back multiply-accumulate operations.
# Note that some vector-add/sub operations are included with certain multiply options, in order to enhance performance of light DSP code.
# <pre>
# 
# 
#  option         Instructions
#  ----------     -------------------------------
#       
#  none                       None 
#  mpy                        MPYW/U, MPY/U, MPYH/U
#  plus_dmpy      mpy       + DMACH, DMPYH, MAC, 
#                             VADD2H,..
#  plus_macd      plus_dmpy + MACD, MPYD, 
#                             VMPY2H,...
#  plus_qmacw     plus_macd + DMACWH, DMPYWH,
#                             QMACH, QMPYH,
#                             VADD2,...
# </pre>
# 
-mpy_option none

# stack_checking --- Stack checking is a mechanism for checking stack accesses and raising an exception when a stack overflow or underflow is detected.
-stack_checking true

# ll64_option --- This enables support for Load and Store instructions that transfer register pairs to/from memory.
-ll64_option true

# intvbase_preset --- This sets the upper 22 bits of the interrupt vector base configuration register, VECBASE_AC_BUILD.  On reset, that register is loaded into the interrupt vector base address register, INT_VECTOR_BASE.  Because this value is the upper 22 bits, the vector base is aligned to a 1K-byte boundary.
-intvbase_preset 0x0

# intvbase_ext --- Set this option to drive the upper 22 bits of the interrupt base vector externally, using signal intvbase_in.
-intvbase_ext false

# nmi_option --- Set this option to enable non-maskable interrupt. 
-nmi_option false

# rgf_num_regs --- This defines the size (in 32b registers) of the processor register file.
-rgf_num_regs 32

# rgf_num_banks --- two or more register banks are useful when Fast IRQ option is selected, but multiple banks may be selected even without Fast IRQ.
-rgf_num_banks 2

# infer_alu_adder --- infer: datapath is described as behavioral code: A + B
# instantiate: datapath is instantiated as a detailed multi-stage code of a carry-lookahead adder.  It is generally preferable to use the infer option when using DesignWare library components and add directives for your target synthesizer.
-infer_alu_adder instantiate

# infer_mpy_wtree --- infer: datapath is described as behavioral code: A * B
# instantiate: datapath is instantiated as a detailed multi-stage code of a Wallace Tree multiplier.   It is preferable  to use the instantiate option; the infer option is intended for simulation only.
-infer_mpy_wtree instantiate

# aux_volatile_base --- Sets the initial base memory region (inclusive) assignment for volatile system memory
-aux_volatile_base 15

# aux_volatile_limit --- Sets the initial upper limit (exclusive) memory region assignment for volatile system memory
-aux_volatile_limit 0

# aux_volatile_disable --- Sets the initial value of Disable Volatile Region bit (on reset)
-aux_volatile_disable false

# aux_volatile_strict_ordering --- Sets the initial value of Strict Ordering bit for the volatile region (on reset)
-aux_volatile_strict_ordering true

# bist_option --- MMB bus on cpu port and accessibility of memories through MMB bus for BIST.
-bist_option false

# scantest_ram_bypass_mux --- This mux is used to make logic trapped between flops and memory (aka shadow logic) to be covered by scantest without requiring advanced sequential ATPG on the memory to be applied. Will add delay to functional access time
-scantest_ram_bypass_mux false

# power_domains --- Add power domains and propagates power-gate control signals to the top level. Also generates UPF constraints and commands in the low-power scripts
-power_domains true

# isolate_has_cdc --- Add 2 flip-flop synchronization registers for isolation signals when they are crossed different clock domain
-isolate_has_cdc false

# pd1_clk_gate_ctrl --- provide an input port to gated/ungated PD1 domain clock
-pd1_clk_gate_ctrl false

# pwr_up_on_int --- Place interrupt and timer logic in core's always-on power domain to support wake-up on interrupt or timer expiry
-pwr_up_on_int false

# dvfs --- Add logics to allow dynamic controlling of voltage and frequency and propagates the associated control signals to the top level
-dvfs true

# clock_gating --- This enables the insertion of architectural clock gate elements in the design. By enabling this option, the clocks to various parts of the design will be disabled when the logic they drive is not in use to save power.
-clock_gating true

# cpu_top_add_ppb_dccm_dmi --- Add a pipeline stage for DCCM DMI. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_dccm_dmi false

# cpu_top_add_ppb_lqwq_mem --- Add a pipeline stage for LQWQ MEM. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_lqwq_mem false

# cpu_top_add_ppb_lqwq_per0 --- Add a pipeline stage for LQWQ PER0. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_lqwq_per0 false

# cpu_top_add_ppb_lqwq_per1 --- Add a pipeline stage for LQWQ PER1. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_lqwq_per1 false

# cpu_top_add_ppb_dcache_rf --- Add a pipeline stage for DCACHE RF. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_dcache_rf false

# cpu_top_add_ppb_dcache_cb --- Add a pipeline stage for DCACHE CB. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_dcache_cb false

# cpu_top_add_ppb_iccm0_dmi --- Add a pipeline stage for ICCM0 DMI. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_iccm0_dmi false

# cpu_top_add_ppb_iccm1_dmi --- Add a pipeline stage for ICCM1 DMI. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_iccm1_dmi false

# cpu_top_add_ppb_icache_rf --- Add a pipeline stage for ICACHE RF. This may be helpful for large clusters and hierarchical layout to assist timing closure at high frequency, but adds cycle latency.
-cpu_top_add_ppb_icache_rf false

# has_biu --- Use internal BIU instead of the cluster BIU. 
-has_biu false

# br_bc_entries --- The number of entries in the branch cache of the branch prediction unit. An entry can store information about 2 branch or jump instructions. More entries means that the branch predictor can keep track of more branch instructions at the same time.
-br_bc_entries 2048

# br_pt_entries --- The number of 2-bit predictors in the branch prediction unit to predict the direction (taken or not taken) of conditional branches. The prediction algorithm is Gshare. More entries means more bits of global branch history can be tracked for more branch or jump instructions at the same time.
-br_pt_entries 16384

# br_rs_entries --- The number of entries in the return address stack of the branch prediction unit. For subroutine calls and returns the return address is predicted using this stack. More entries means deeper subroutine nesting levels can be predicted accurately.
-br_rs_entries 8

# br_bc_full_tag --- The size of the tag used in the branch cache of the branch prediction unit. A full size tag avoids aliasing of branches in the branch cache, but is more costly in hardware.
-br_bc_full_tag true

# br_bc_tag_size --- If a partial tag is used, this option sets the size of that tag. The chance of aliasing declines exponentially with the size of the tag and in a lot of applications a small tag works fine.
-br_bc_tag_size 4

# br_tosq_entries --- The Top-Of-Stack queue keeps track of subroutine calls and returns that are in progress at the same time in the processor. A small number saves hardware, a large number gives highest performance even when there are dense subroutine call and return patterns.
-br_tosq_entries 8

# br_fb_entries --- The size of the instruction buffer that stores instructions that have been fetched but not yet executed in the processor. A larger buffer allows better performance on complex branch and jump patterns at the expense of hardware.
-br_fb_entries 4

# lpb_num --- 0 indicates no loop buffer configured. This specifies the size of loop buffer.A larger buffer number allows better power saving on longer loop at the expense of hardwareFor instruction lp, lpcc, dbnz, access from loop buffer instead of icache, iccm, external bus and bpu.After detection of the loop, capture these instructions of the loop in the loop buffer.These instructions will be sent to fetch buffer
-lpb_num 8

# grad_entries --- Graduation entries track post-commit instructions awaiting result retirement. For example, long non-blocking instructions such as divide or certain deeply pipelined APEX instructions.
-grad_entries 8

# uaux_option --- Include a user auxiliary register interface
-uaux_option false


######## AGU --- com.arc.hardware.HS.AGU.1_0 ########

# Create AGU
-create com.arc.hardware.HS.AGU.1_0 System.Cluster.CPUisle__3.ARCv2HS.AGU

######## ARCHS_dual_issue --- com.arc.hardware.HS.ARCHS_dual_issue.1_0 ########

# Create ARCHS_dual_issue
-create com.arc.hardware.HS.ARCHS_dual_issue.1_0 System.Cluster.CPUisle__3.ARCv2HS.ARCHS_dual_issue

######## DSP --- com.arc.hardware.HS.DSP.1_0 ########

# Create DSP
-create com.arc.hardware.HS.DSP.1_0 System.Cluster.CPUisle__3.ARCv2HS.DSP

# dsp_itu --- Enable/disable support for ITU bit-accurate 1 bit fractional shift before accumulation, else 1-bit fractional shift result after accumulation only
-dsp_itu true

# dsp_divsqrt --- Enable/disable support for divide and square root operations: DIV(U)(F), REM(U), SQRT(F)
-dsp_divsqrt radix4

# dsp_wide --- Enable/disable support for 4x16x16 and 2x32x16 MAC instructions
-dsp_wide true

# dsp_impl --- The datapath components may be inferred from Verilog for better area or optimized using carry-save components for better timing
-dsp_impl optimized


######## FastMath --- com.arc.hardware.FastMath.1_0 ########

# Create FastMath
-create com.arc.hardware.FastMath.1_0 System.Cluster.CPUisle__3.ARCv2HS.FastMath

# FastMath --- Command line option for EIA extension component 'FastMath'.
-fastmath ""

# support_div --- Include recip & div inst
-support_div true

# support_sqrt --- Include sqrt inst
-support_sqrt true

# support_sat --- Include sath rndh & adds inst
-support_sat true

# support_trig --- Include trig log2 & exp2 inst
-support_trig true


######## Floating-point unit --- com.arc.hardware.HS.Floating_point_unit.1_0 ########

# Create Floating-point unit
-create com.arc.hardware.HS.Floating_point_unit.1_0 "System.Cluster.CPUisle__3.ARCv2HS.Floating-point unit"

# fpu_dp_option --- This enables double-precision floating point instructions.
-fpu_dp_option true

# fpu_div_option --- This enables divide & square-root instructions
-fpu_div_option true

# fpu_fma_option --- This enables the multiply & accumulate instructions.
-fpu_fma_option true


######## Interrupt Controller --- com.arc.hardware.HS.Interrupt_Controller.1_0 ########

# Create Interrupt Controller
-create com.arc.hardware.HS.Interrupt_Controller.1_0 "System.Cluster.CPUisle__3.ARCv2HS.Interrupt Controller"

# number_of_interrupts --- This is the total number of interrupts available to the core.  Some interrupts are allocated statically to a specific interrupt line (for example, timer interrupts).  For more information on Interrupt and register-file options, see DesignWare ARCv2 ISA Programmers Reference Manual.
-number_of_interrupts 73

# number_of_levels --- Priority levels in the interrupt controller.
-number_of_levels 2

# external_interrupts --- This is the total number of interrupt pins available for external system components.  This parameter must be less than the total number of interrupts.
-external_interrupts 70

# firq_option --- This enables the fast-interrupts option, (priority level 0 interrupts), which uses an alternate register bank (if configured) instead of saving the context to memory.
-firq_option true


######## Real-time Counter --- com.arc.hardware.HS.Real_time_Counter.1_0 ########

# Create Real-time Counter
-create com.arc.hardware.HS.Real_time_Counter.1_0 "System.Cluster.CPUisle__3.ARCv2HS.Real-time Counter"

######## Timer 0 --- com.arc.hardware.HS.Timer_0.1_0 ########

# Create Timer 0
-create com.arc.hardware.HS.Timer_0.1_0 "System.Cluster.CPUisle__3.ARCv2HS.Timer 0"

# timer_0_int_level --- This sets the interrupt level (and implicitly the priority: level 0 is highest) of timer 0.
-timer_0_int_level 1


######## Timer 1 --- com.arc.hardware.HS.Timer_1.1_0 ########

# Create Timer 1
-create com.arc.hardware.HS.Timer_1.1_0 "System.Cluster.CPUisle__3.ARCv2HS.Timer 1"

# timer_1_int_level --- This sets the interrupt level (and implicitly the priority: level 0 is highest) of timer 1.
-timer_1_int_level 0


######## DCCM --- com.arc.hardware.HS.DCCM.1_0 ########

# Create DCCM
-create com.arc.hardware.HS.DCCM.1_0 System.Cluster.CPUisle__3.ARCv2HS.DCCM

# dccm_size --- This defines the size of the Data Closely Coupled Memory (DCCM) in bytes
-dccm_size 65536

# dccm_base --- Sets the initial memory region assignment for DCCM base address
-dccm_base 6

# dccm_dmi --- This enables external access through a DMI (direct memory interface) port.
-dccm_dmi true

# dccm_dmi_partial_ecc --- This enables the partial write support through a DMI (direct memory interface) port.
-dccm_dmi_partial_ecc false

# dccm_mem_cycles --- This defines the number of cycles dedicated to the each DCCM Memory bank.
-dccm_mem_cycles 2

# dccm_mem_posedge --- This option clocks the DCCM memory banks on the positive edge of the clock
-dccm_mem_posedge false

# dccm_mem_banks --- This option selects the number of DCCM memory banks
-dccm_mem_banks 4

# dccm_ecc_option --- This specifies error checking for on-chip DCCM rams.
# SECDED means single-error correction and double-error detection.
-dccm_ecc_option none


######## Data Cache --- com.arc.hardware.HS.Data_Cache.1_0 ########

# Create Data Cache
-create com.arc.hardware.HS.Data_Cache.1_0 "System.Cluster.CPUisle__3.ARCv2HS.Data Cache"

# dc_size --- This defines the total size of the Data Cache in bytes.
-dc_size 65536

# dc_bsize --- This defines the cache line length in bytes.
-dc_bsize 64

# dc_bus_data_width --- This defines the cache bus width for refills and evictions.
-dc_bus_data_width 64

# dc_mem_cycles --- This defines the number of cycles dedicated to the Data Cache data memories.
-dc_mem_cycles 2

# dc_mem_posedge --- This option clocks the Data Cache memories on the positive edge of the clock
-dc_mem_posedge false

# dc_ecc_option --- This specifies error checking for DCACHE Tag, Data rams.
# SECDED means single-error correction and double-error detection.
-dc_ecc_option none


######## ICCM0 --- com.arc.hardware.HS.ICCM0.1_0 ########

# Create ICCM0
-create com.arc.hardware.HS.ICCM0.1_0 System.Cluster.CPUisle__3.ARCv2HS.ICCM0

# iccm0_size --- This defines the size of ICCM0 in bytes.This ICCM has 0 wait states.
-iccm0_size 262144

# iccm0_base --- Sets the initial memory region assignment for ICCM0
-iccm0_base 6

# iccm0_dmi --- This enables external access through a DMI (direct memory interface) port.
-iccm0_dmi true

# iccm0_ecc_option --- This specifies error checking for on-chip ICCM0
-iccm0_ecc_option none


######## Instruction Cache --- com.arc.hardware.HS.Instruction_Cache.1_0 ########

# Create Instruction Cache
-create com.arc.hardware.HS.Instruction_Cache.1_0 "System.Cluster.CPUisle__3.ARCv2HS.Instruction Cache"

# ic_size --- This defines the total size of the instruction cache in bytes.
-ic_size 65536

# ic_ways --- This defines the number of cache ways
-ic_ways 4

# ic_bsize --- This defines the cache line length in bytes.
-ic_bsize 64

# ic_disable_on_reset --- The instruction cache may be enabled immediately after reset, depending on this option.  If this option is set to true, the instruction cache is disabled and instruction fetches bypass the cache, accessing system memory directly.
-ic_disable_on_reset false

# ic_pipeline_bus --- This option inserts a pipeline register on the instruction cache's refill bus from memory. This option can be used to ease timing in configurations where cores are not closely located with level-2 cache, for example.
-ic_pipeline_bus true

# ic_ecc_option --- This specifies error checking for ICACHE Tag, Data rams.
# SECDED means single-error correction and double-error detection.
-ic_ecc_option none


######## JTAG Interface --- com.arc.hardware.HS.JTAG_Interface.1_0 ########

# Create JTAG Interface
-create com.arc.hardware.HS.JTAG_Interface.1_0 "System.Cluster.CPUisle__3.ARCv2HS.JTAG Interface"

######## Debug Interface --- com.arc.hardware.HS.Debug_Interface.1_0 ########

# Create Debug Interface
-create com.arc.hardware.HS.Debug_Interface.1_0 "System.Cluster.CPUisle__3.ARCv2HS.Debug Interface"

# dbg_en_option --- Adds an enable pin to the existing debug interface
-dbg_en_option false

# dbg_apb_option --- Adds an additional APB debug port alongside the BVCI one
-dbg_apb_option false

# dbg_apb_ratio --- Sets the clock ratio for the APB debug port to core clock
-dbg_apb_ratio 12


######## Actionpoints --- com.arc.hardware.HS.Actionpoints.1_0 ########

# Create Actionpoints
-create com.arc.hardware.HS.Actionpoints.1_0 System.Cluster.CPUisle__3.ARCv2HS.Actionpoints

# num_actionpoints --- This is the number of trigger events available.
-num_actionpoints 8

# aps_feature --- Selects Actionpoint feature set
-aps_feature full


######## SmaRT --- com.arc.hardware.HS.SmaRT.1_0 ########

# Create SmaRT
-create com.arc.hardware.HS.SmaRT.1_0 System.Cluster.CPUisle__3.ARCv2HS.SmaRT

# smart_stack_entries --- This specifies the number of entries in the trace buffer.
-smart_stack_entries 64

# smart_implementation --- Flip-flop = FF-based design.  Memory = memory-based design (provides better density for larger trace buffers).
-smart_implementation memory


######## Real-time trace producer --- com.arc.hardware.HS.Real_time_trace_producer.1_0 ########

# Create Real-time trace producer
-create com.arc.hardware.HS.Real_time_trace_producer.1_0 "System.Cluster.CPUisle__3.ARCv2HS.Real-time trace producer"

# rtt_feature_level --- 'small' means that program trace only is available.  `medium' adds data trace.  `full' adds core and aux register trace.
-rtt_feature_level medium

# rtt_mux_option --- Support builds with less RTT producers than the number of cores.Currently only valid for 4:2 muxing
-rtt_mux_option false

# rtt_cti_sync --- Support CTI synchronized to ATCLK
-rtt_cti_sync false


######## Memory Protection Unit --- com.arc.hardware.HS.Memory_Protection_Unit.1_0 ########

# Create Memory Protection Unit
-create com.arc.hardware.HS.Memory_Protection_Unit.1_0 "System.Cluster.CPUisle__3.ARCv2HS.Memory Protection Unit"

# mpu_num_regions --- Number of configured memory regions.
-mpu_num_regions 8


######## Memory Management Unit --- com.arc.hardware.HS.Memory_Management_Unit.1_0 ########

# Create Memory Management Unit
-create com.arc.hardware.HS.Memory_Management_Unit.1_0 "System.Cluster.CPUisle__3.ARCv2HS.Memory Management Unit"

# mmu_ecc_option --- This specifies error checking for on-chip MMU rams.
# SECDED means single-error correction and double-error detection.
-mmu_ecc_option none

# mmu_itlb_num_entries --- This is the number of micro ITLB entries.
-mmu_itlb_num_entries 4

# mmu_dtlb_num_entries --- This is the number of micro DTLB entries.
-mmu_dtlb_num_entries 8

# mmu_ntlb_num_entries --- This is the number of joint TLB normal page entries.
-mmu_ntlb_num_entries 1024

# mmu_page_size_sel0 --- This is the page size of each joint TLB normal page.
-mmu_page_size_sel0 8K

# mmu_stlb_num_entries --- This is the number of joint TLB super page entries.
-mmu_stlb_num_entries 16

# mmu_page_size_sel1 --- This is the page size of each joint TLB super page.
-mmu_page_size_sel1 2M

# mmu_pae_enabled --- If enabled, PAE provides for a 40-bit physical memory address.
-mmu_pae_enabled true

# mmu_shared_lib --- If enabled, the shared-library ASID feature is supported.
-mmu_shared_lib true


######## Performance Monitor --- com.arc.hardware.HS.Performance_Monitor.1_0 ########

# Create Performance Monitor
-create com.arc.hardware.HS.Performance_Monitor.1_0 "System.Cluster.CPUisle__3.ARCv2HS.Performance Monitor"

# pct_counters --- Number of counters for performance monitoring.
-pct_counters 8

# pct_interrupt --- When a counter overflows, an interrupt is generated.
-pct_interrupt true


######## ARC_RTT --- com.arc.hardware.ARC_RTT.1_0 ########

# Create ARC_RTT
-create com.arc.hardware.ARC_RTT.1_0 System.ARC_RTT

# rtt_coresight_option --- Please select CoreSight ATB interface to offload the data from RTT 
-rtt_coresight_option false

# rtt_cnn_option --- CNN Trace option 
-rtt_cnn_option false

# rtt_src_arb_pipeline --- Add pipeline stage to src_arb 
-rtt_src_arb_pipeline false

# rtt_num_filters --- Please select the Number of RTT Address Filters 
-rtt_num_filters 4

# rtt_atb_ratio --- Sets the clock ratio for the ATB offload port
-rtt_atb_ratio 3

# has_nexus_if --- Please select Nexus interface to offload the data from RTT 
-has_nexus_if true

# has_on_chip_mem --- Please select the on-chip memory option to store the trace data in shared memory 
-has_on_chip_mem true

# nexus_data_wdt --- Please select the Nexus Data Width to offload the data from RTT 
-nexus_data_wdt 8

# internal_memory_size --- Please select internal memory size to capture the trace data 
-internal_memory_size 64k

# ram_type --- Please select Types of internal memories to be inferred for the logic 
-ram_type 2_PORT

# rtt_cstm_var_wdt --- This gives option variable length CSTM.
-rtt_cstm_var_width false

# rtt_sytm_option --- Enable System Timestamp Message generation. 
-rtt_sytm_option true

# rtt_sytm_ctr_option --- System Timestamp Counter Option. 
-rtt_sytm_ctr_option true

# rtt_power_domains --- Adds isolation signal inputs/power switch controls for use in UPF flow when configuring power domains.
-rtt_power_domains true


######## ARConnect --- com.arc.hardware.ARConnect.1_0 ########

# Create ARConnect
-create com.arc.hardware.ARConnect.1_0 System.ARConnect

# skip_build --- Customers cannot see this option.  If set, this component is not built. This saves time if you've already built the design and no subsequent change requires this component to be rebuilt.
-skip_build false

# mcip_def_div2ref --- This specifies the clock division factor at reset. This option is irrelevant to any RTL featuresIt is only used for ARCv2MSS clock controller to generate ARConnect clock in ARChitect simulation environment, and the value N means ARConnect is running at (1/N) x ref_clk.
-mcip_def_div2ref 1

# mcip_has_cdc --- This specifies whether Clock-Domain-Crossing logics implemented in all the interfaces between cores and ARConnect. If this option is configured, the ARConnect can be put in completely-independent clock domain asynchronous to connected cores.
-mcip_has_cdc false

# mcip_has_intrpt --- This specifies whether the Inter-core Interrupt Unit exists. NOTE: in single-core configuration the ICI can only be used to generate interrupt to external system, other inter-core interrupt functionalities are pointless.
-mcip_has_intrpt true

# mcip_has_sema --- This specifies whether the Inter-core Semaphore Unit exists. NOTE: in single-core configuration the inter-core semaphores functionalities are pointless.
-mcip_has_sema true

# mcip_sema_num --- This specifies the number of semaphores in the Inter-core Semaphores Unit
-mcip_sema_num 16

# mcip_has_msg_sram --- This specifies whether the Inter-core Message Unit exists. NOTE: in single-core configuration the inter-core message functionalities are pointless.
-mcip_has_msg_sram true

# mcip_msg_sram_size --- This specifies the bytes of SRAM in the Inter-core Message Unit
-mcip_msg_sram_size 512

# mcip_msg_mem_posedge --- True: The access path to message SRAM is 1 clock cycle, and inter-core message passing SRAM are clocked on the positive edge of the clock; False: The access path to message SRAM is 1.5 cycles, inter-core message passing SRAM are clocked on the negative edge of the clock. Note: The 1.5 cycles path use clock negetive edge for SRAM, but can acheive higher frequency. No performance difference caused by the value of this option
-mcip_msg_mem_posedge false

# mcip_msg_ecc --- This specifies the ECC mode of message SRAM. none = No checking; parity = Parity only; SECDED = single-error correction and double-error detection (SECDED)
-mcip_msg_ecc none

# mcip_bist_option --- This specifies whether MMB bus interface generates. 0 = No MMB based memory test through the MMB bus interface; 1 = Has MMB based memory test through the MMB bus interface.
-mcip_bist_option false

# mcip_has_debug --- This specifies whether the Inter-core Debug Unit exists. NOTE: in single-core configuration the inter-core debug functionalities are pointless.
-mcip_has_debug true

# mcip_has_grtc --- This specifies whether the Global Real-Time Counter Unit exists.
-mcip_has_grtc true

# mcip_has_idu --- This specifies whether the Interrupt Distribution Unit exists
-mcip_has_idu true

# mcip_idu_cirq_num --- This specifies the number of common interrupts supported by IDU
-mcip_idu_cirq_num 64

# mcip_has_bsu --- This specifies whether the ARConnect Slave Interface Unit exists
-mcip_has_bsu false

# mcip_bsu_type --- This specifies the bus protocol of Bus Slave Unit
-mcip_bsu_type AXI

# mcip_has_pmu --- Specifies whether ARConnect Power Management Unit Exists. If disabled, external PMU should be used. If enabled, internal ARConnect PMU is used. This option takes effect only is Power Domains are enabled
-mcip_has_pmu true

# mcip_power_domains --- Enables Power Domains so that the ARConnect logic and memories are split between Always-On, PD1 and PD2 domains
-mcip_power_domains true

# mcip_aap_num --- This specifies the  number of ARConnect Acclearator Ports
-mcip_aap_num 0

# mcip_xnn_aap_num --- This specifies the  number of ARConnect Accelerator Ports dedicated for ARC internal components, e.g., CNN2.0
-mcip_xnn_aap_num 0

# mcip_xnn_aap0_client --- Name of the client
-mcip_xnn_aap0_client AAP0

# mcip_xnn_aap1_client --- Name of the client
-mcip_xnn_aap1_client AAP1

# mcip_xnn_aap2_client --- Name of the client
-mcip_xnn_aap2_client AAP2

# mcip_xnn_aap3_client --- Name of the client
-mcip_xnn_aap3_client AAP3

# mcip_internal_dev --- If configured this option as 'true', it will generate some system-verilog assertion codes in the RTLs which is not expected in offical release
-mcip_internal_dev false


######## ARCv2HS CCT --- cct.HS.1_0 ########

# Create ARCv2HS CCT
-create cct.HS.1_0 "System.ARCv2HS CCT"

# cct --- 
# 	Option used to add a CCT to the design for command-line builds
# 	Without this architect can't add this component to a build
# 	via a cmdline -create command.  
# 	with old scripts.
# 	
-cct true

# no_hostlink --- 
# This prevents the inclusion of the hostlink library when compiling
# C or C++ programs.  The resultant executable, if it contains printfs,
# will print to an internal fixed buffer __mwwrite_buf.  
# Other hostlink operations that require debugger assistance, such as file
# opens, will fail.
# 
# Hostlink references incur memory cycles at unpredictable times and 
# so can perturb cycle-timing results.  Without hostlink,
# the debugger will not in any way interfere with the target while it is running.  
# Therefore this option is useful for simulation in which you want precisely the
# same cycle timing to occur each time you run, or for accurate power consumption results.
# 	
-cct_no_hostlink false


######## BusFabric --- com.arc.hardware.ARCv2MSS.BusFabric.1_0 ########

# Create BusFabric
-create com.arc.hardware.ARCv2MSS.BusFabric.1_0 System.BusFabric

# alb_mss_fab_ahb_b2b --- This option is used to choose selcet two ahb-lite slave implementationsWhen selecting true, ahb-lite slave can support back2back transaction for ahb-lite burst. 
-alb_mss_fab_ahb_b2b true

# alb_mss_fab_def_div2ref --- This specifies the clock division factor at reset. It is used for mss clock controller to generate mss fabric clock, and the value N means mss fabric is running at (1/N) x ref_clk.
-alb_mss_fab_def_div2ref 2

# alb_mss_fab_lat --- This specifies the maximum latency in the master latency units.
-alb_mss_fab_lat 0

# alb_mss_fab_def_lat --- This specifies the latency after reset for the master latency units.
-alb_mss_fab_def_lat 0

# alb_mss_fab_def_wr_bw --- This specifies the write channel bandwidth parameter after reset for the master bandwidth control units.
-alb_mss_fab_def_wr_bw 0

# alb_mss_fab_def_rd_bw --- This specifies the read channel bandwidth parameter after reset for the master bandwidth control units.
-alb_mss_fab_def_rd_bw 0

# alb_mss_ccm_base --- This specifies the base address at which the ICCM and DCCM DMIs will be placed in the memory map. The address should be divided by 4KB i.e. do not specify the lower 12 bits of the address.
-alb_mss_ccm_base 0x4_0000


######## ClkCtrl --- com.arc.hardware.ARCv2MSS.ClkCtrl.1_0 ########

# Create ClkCtrl
-create com.arc.hardware.ARCv2MSS.ClkCtrl.1_0 System.ClkCtrl

# alb_mss_clkctrl_base_addr --- This specifies the clock controller base address in the memory map, divided by 4KB i.e. do not specify the lower 12 bits of the address.
-alb_mss_clkctrl_base_addr 0xc_0000

# alb_mss_clkctrl_bypass_mode --- If true then all clock dividers/gaters in the clock controller are bypassed, clock ratio is not supported and the division options/registers are overriden
-alb_mss_clkctrl_bypass_mode false

# alb_mss_sim_timeout_limit --- This specifies the TIMEOUT value for CCT simulation. If you want to disable this TIMEOUT control, set it's value to 0 (by default), otherwise, set the appropriate values according to simulation requirement
-alb_mss_sim_timeout_limit 500000000


######## SnoopTrafficGen --- com.arc.hardware.ARCv2MSS.SnoopTrafficGen.1_0 ########

# Create SnoopTrafficGen
-create com.arc.hardware.ARCv2MSS.SnoopTrafficGen.1_0 System.SnoopTrafficGen

# alb_mss_snoop_trafgen_base_addr --- This specifies the snoop traffic generator base address in the memory map, divided by 4KB i.e. do not specify the lower 12 bits of the address.
-alb_mss_snoop_trafgen_base_addr 0xc_0002


######## Implementation --- com.arc.hardware.implementation.1_0 ########

# Create Implementation
-create com.arc.hardware.implementation.1_0 System.Implementation

# ClockSpeed --- Target clock speed of the system
-clock_speed 1125

# ClockSkew --- The clock skew for the system
-clock_skew 0.2

# HoldMargin --- Margin for hold time checks
-hold_margin 0.05

# Floorplan --- Floorplan giving relative placement of the RAMs (or hard macro cpus for 2nd tier floorplan) for the given configuration
-floorplan HS47Dx4_SLC_CSM_RTT_full

# JTAGFrequency --- Select the frequency of the JTAG clock Tck (in MHz).
# 
# The JTAG clock speed has to be less than 1/2 of the cpu clock otherwise the signals on the BVCI interface are not guaranteed to be valid.
# 
# NOTE: The RTL simulations will work when the JTAG clock frequency is set to half the CPU clock, however this may not be the case when simulating at gate level due to delays on the IO pads.
# 
# The default is set to 10 MHz so that there is no conflict when simulating with an ARCangel3 at 30MHz. (30 > 10*2)
# 
# The speed of simulation can be greatly increased by using a faster JTAG clock, but a dependency will warn if it exceeds 1/2 of the cpu clock.
# 
-jtag_tclk 10

# execution_trace_level --- 
# This traces committed instructions as they execute, and gathers statistics
# visible in the debugger for counting instructions & cycle delays.
# At the "stats" level ony the statistics are gathered and no trace is printed.
# "file" is equivalent to "full", but the results go to a trace .txt file instead.
# 
-execution_trace_level file

# tb_trace --- 
# Enable instruction execution trace.
# This is available to arc_dev licensees (internal developers) only.
# It applies only to EM cores and has no effect with HS cores.
# 
-tb_trace false

# zero_based_arcnum --- 
# In a multicore build, number ARCs from 0.
# If this is not selected, arcs are numbered from 1.
# (This provides the initial value to the arcnum signal.)
# 
-zero_based_arcnum true

# unique_clk --- 
# In a multicore build, each CPU has by default its own unique clk input pin from top-level down to CPU instance.
# Setting this option to false forces the clock net  going to each CPU's clock input pin to be the same,  effectively driving all multicore components from same top-level clock pin
# 
-unique_clk false

# generate_ipxact --- 
# Generate ipxact.xml file describing the CPUisle or archipelago frontier
# 
-generate_ipxact false

# ipxact_relative_path_names --- 
# Use relative path names for Verilog files in the ipxact.
# Otherwise, absolute path names are used.
# 
-ipxact_relative_path_names true

# optional_encryption --- 
# When selected, encrypted RTL output is generated.
# 	
-optional_encryption false

# ignore_encrypt_license --- 
# When selected, pretend the encryption license is missing.  For testing.
# 	
-ignore_encrypt_license false

# ignore_clear_license --- 
# When selected, pretend the cleartest license is missing.  For testing.
# 	
-ignore_clear_license false


######## SRAMCtrl --- com.arc.hardware.ARCv2MSS.SRAMCtrl.1_0 ########

# Create SRAMCtrl
-create com.arc.hardware.ARCv2MSS.SRAMCtrl.1_0 System.SRAMCtrl

# alb_mss_mem_region_num --- The number of regions supported in SRAMCtrl component
-alb_mss_mem_region_num 1

# alb_mss_mem0_base_addr --- This specifies the base address of memory region 0 in the memory map, divided by 4KB i.e. do no specify the lower 12 bits of the address.
-alb_mss_mem0_base_addr 0

# alb_mss_mem0_size --- This specifies the memory size of memory region 0.
-alb_mss_mem0_size 4GB

# alb_mss_mem0_attr --- This specifies the memory access attribute of memory region 0.
-alb_mss_mem0_attr Read-Write

# alb_mss_mem0_secure --- This specifies the memory secure attribute of memory region 0.
-alb_mss_mem0_secure Non-Secure

# alb_mss_mem0_lat --- This specifies the maximum latency of memory region 0 .
-alb_mss_mem0_lat 0

# alb_mss_mem0_def_lat --- This specifies the latency after reset of memory region 0.
-alb_mss_mem0_def_lat 0

# alb_mss_mem1_base_addr --- This specifies the base address of memory region 1 in the memory map, divided by 4KB i.e. do no specify the lower 12 bits of the address.
-alb_mss_mem1_base_addr 1048576

# alb_mss_mem1_size --- This specifies the memory size of memory region 1.
-alb_mss_mem1_size 1MB

# alb_mss_mem1_attr --- This specifies the memory access attribute of memory region 1.
-alb_mss_mem1_attr Read-Write

# alb_mss_mem1_secure --- This specifies the memory secure attribute of memory region 1.
-alb_mss_mem1_secure Non-Secure

# alb_mss_mem1_lat --- This specifies the maximum latency of memory region 1 .
-alb_mss_mem1_lat 0

# alb_mss_mem1_def_lat --- This specifies the latency after reset of memory region 1.
-alb_mss_mem1_def_lat 0

# alb_mss_mem2_base_addr --- This specifies the base address of memory region 2 in the memory map, divided by 4KB i.e. do no specify the lower 12 bits of the address.
-alb_mss_mem2_base_addr 1048576

# alb_mss_mem2_size --- This specifies the memory size of memory region 2.
-alb_mss_mem2_size 1MB

# alb_mss_mem2_attr --- This specifies the memory access attribute of memory region 2.
-alb_mss_mem2_attr Read-Write

# alb_mss_mem2_secure --- This specifies the memory secure attribute of memory region 2.
-alb_mss_mem2_secure Non-Secure

# alb_mss_mem2_lat --- This specifies the maximum latency of memory region 2 .
-alb_mss_mem2_lat 0

# alb_mss_mem2_def_lat --- This specifies the latency after reset of memory region 2.
-alb_mss_mem2_def_lat 0

# alb_mss_mem3_base_addr --- This specifies the base address of memory region 3 in the memory map, divided by 4KB i.e. do no specify the lower 12 bits of the address.
-alb_mss_mem3_base_addr 1048576

# alb_mss_mem3_size --- This specifies the memory size of memory region 3.
-alb_mss_mem3_size 1MB

# alb_mss_mem3_attr --- This specifies the memory access attribute of memory region 3.
-alb_mss_mem3_attr Read-Write

# alb_mss_mem3_secure --- This specifies the memory secure attribute of memory region 3.
-alb_mss_mem3_secure Non-Secure

# alb_mss_mem3_lat --- This specifies the maximum latency of memory region 3 .
-alb_mss_mem3_lat 0

# alb_mss_mem3_def_lat --- This specifies the latency after reset of memory region 3.
-alb_mss_mem3_def_lat 0

# alb_mss_mem_is_default_slave --- If true then all transactions without destination will be routed here.
-alb_mss_mem_is_default_slave true

# alb_mss_mem_default_space --- This specifies the memory space width of the system.
-alb_mss_mem_default_space 32

# alb_mss_mem_wr_rsp_ahead --- If true then write response of SRAMCtrl is returned ahead at the same cycle of wr_last so that AHB protocol can achieve its best write performance. Notes: It's recommended that this option should only enabled when the master accessing the memory is AHB type and attempts to obtain the best write performance. For AXI protocol, please disable it to avoid the protocol violation
-alb_mss_mem_wr_rsp_ahead false

# alb_mss_mem_conflict_free --- If true then all masters can access the memory simultaneously without confliction. It is especially used in some benchmarking scenarios and not recommended for regular CCT tests
-alb_mss_mem_conflict_free false

# alb_mss_mem_data_width --- This specifies the memory data width
-alb_mss_mem_data_width 64


######## Synopsys XG Synthesis Flow --- com.synopsys.SynthesisFlow_XG.1_0 ########

# Create Synopsys XG Synthesis Flow
-create com.synopsys.SynthesisFlow_XG.1_0 "System.Synopsys XG Synthesis Flow"

# synopsysSynthesisFlow --- Add the synopsys SynthesisFlow component
-synopsys_xg_synthesis true

# Inbound12FFCopt --- 0:no limit imposed; 1-20 : the %number of cells which are allowed to be inbound 12-T
-inbound_12ffc_opt 0

# Retiming --- Instruct the design flow to retime modules as specified in retime_module_list
-enable_retiming false

# RetimeModuleList --- List of modules to be retimed
-retime_module_list ""

# InsertScanChains --- Instruct the design flow to automatically add in the scan chain structures.
-insert_scan_chains false

# ScanChains --- Indicates the number of scan chains to be used when stitching the scan registers;
# 	This option replaces the obsolete ScanChains option in implementation/System component.
-scan_chains 4

# InsertLogicBist --- Instruct the design flow to automatically add in the logic BIST structures.
-insert_logic_bist false

# LogicBistChains --- Indicates the number of logic BIST chains to be used when inserting Logic BIST
-logic_bist_chains 96

# PatternCounterWidth --- Indicates the width of logic BIST pattern counter
-pattern_counter_width 16

# InsertTestPoints --- Instruct the design flow to automatically add test points when inserting DfT structures.
-insert_test_points false

# PowerRampUp --- Specifies whether to run power ramp-up patterns prior to self-test.
-power_ramp_up false

# TestPointMethod --- Test Point Method
# DesignCompiler
# SpyGlassADV
-test_point_method DesignCompiler

# AutoUngroup --- Instruct the synthesis compile step to enable auto-ungrouping
-auto_ungroup true

# InsertClockGating --- When set this will cause Clock Gating Logic to be inserted during synthesis.
-insert_clock_gating true

# UPF --- When set this will cause UPF flow (isolation cell insertion) to be configured during synthesis.
-upf false

# DcUltra --- Enables Ultra optimization during synthesis.
-dc_ultra true

# MBFF --- Enables Targeting of multibit flops assuming library has them. Can cause performance drop but may give area/power saving
-mbff false

# DCTopographicMode --- Use DC Topographic mode for placement aware synthesis.
-dc_topographic true

# Hierarchical --- Enables hierarchical implementation flow.
-hierarchical false

# SaveDiskSpace --- Save Disk Space by not writing out certain large files (SDF, DEF, SPBF. Only use if gatelevel simulation  is not being used
-save_disk_space false


######## Synopsys_TSMC_28nm_HPM_HS_SVT_LVT_ULVT --- technology_library.Synopsys_TSMC_28nm_HPM_HS_SVT_LVT_ULVT.1_0 ########

# Create Synopsys_TSMC_28nm_HPM_HS_SVT_LVT_ULVT
-create technology_library.Synopsys_TSMC_28nm_HPM_HS_SVT_LVT_ULVT.1_0 System.Synopsys_TSMC_28nm_HPM_HS_SVT_LVT_ULVT

# Synopsys_TSMC_28nm_HPM_HS_SVT_LVT_ULVT --- Option specified to allow this library to be instantiated from the command line
-synopsys_tsmc_28nm_hpm_hs_svt_lvt_ulvt true

# TechnologyType --- The target technology for the design
-technology asic

# Geometry --- The desired ASIC geometry used for synthesis.
-geometry 0.028

# TechCellFile --- The path and file name of the Verilog technology library cell file.
-tech_cell_path "/slowfs/de02dwt2p038/HighSpeed/ts28nmhssst/latest/verilog/3.0/ts28nmhssst.v /slowfs/de02dwt2p038/HighSpeed/ts28nmhlsst/latest/verilog/3.0/ts28nmhlsst.v /slowfs/de02dwt2p038/HighSpeed/ts28nmhvsst/latest/verilog/3.0/ts28nmhvsst.v /slowfs/de02dwt2p038/HighSpeed/ts28nmhspst/latest/verilog/3.0/ts28nmhspst.v /slowfs/de02dwt2p038/HighSpeed/ts28nmhlpst/latest/verilog/3.0/ts28nmhlpst.v"

# TechCellLef --- A comma separated list of LEF files. The first file must contain the LEF technology information in addition to any macros defined. Subsequent files may contain additional macro definitions e.g. definitions of the standard cells.
-tech_cell_lef /slowfs/de02dwt2p038/HighSpeed/ts28nmhssst/latest/lef/5.6/ts28nmhssst_m08f0f2f0_UTRDL.lef,/slowfs/de02dwt2p038/HighSpeed/ts28nmhssst/latest/lef/5.6/ts28nmhssst.lef,/slowfs/de02dwt2p038/HighSpeed/ts28nmhlsst/latest/lef/5.6/ts28nmhlsst.lef,/slowfs/de02dwt2p038/HighSpeed/ts28nmhvsst/latest/lef/5.6/ts28nmhvsst.lef,/slowfs/de02dwt2p038/HighSpeed/ts28nmhspst/latest/lef/5.6/ts28nmhspst.lef,/slowfs/de02dwt2p038/HighSpeed/ts28nmhlpst/latest/lef/5.6/ts28nmhlpst.lef

# TechLibPath --- The path to the synthesis technology library 
-tech_lib_path "/slowfs/de02dwt2p038/HighSpeed/ts28nmhssst/latest/liberty/logic_synth /slowfs/de02dwt2p038/HighSpeed/ts28nmhlsst/latest/liberty/logic_synth /slowfs/de02dwt2p038/HighSpeed/ts28nmhvsst/latest/liberty/logic_synth /slowfs/de02dwt2p038/HighSpeed/ts28nmhspst/latest/liberty/logic_synth /slowfs/de02dwt2p038/HighSpeed/ts28nmhlpst/latest/liberty/logic_synth"

# DontUseList --- List of synthesis library cells NOT to be used.
-dont_use_list "STV_BUF_S_* STV_INV_S_* STV_FDN* STV_FSDN* STV_DEL* STN_* STL_*"

# DrivingCellName --- The name of the driving cell used to set the context for synthesis.
-driving_cell_name STV_BUF_8

# DrivingCellPin --- The name of the ouput pin on the driving cell.
-driving_cell_pin X

# LoadPin --- The load pin of the driving cell.
-load_pin A

# SymbolLib --- The name of the file that contains the symbol library for synthesis.
-symbol_lib ""

# MaxLibFile --- The file name of the max synthesis library
-max_lib_file "ts28nmhssst_ss0p81v125c.db ts28nmhlsst_ss0p81v125c.db ts28nmhvsst_ss0p81v125c.db ts28nmhspst_ss0p81v125c.db ts28nmhlpst_ss0p81v125c.db"

# MaxLibName --- The name of the max library used for synthesis.
-max_lib_name "ts28nmhssst_ss0p81v125c ts28nmhlsst_ss0p81v125c ts28nmhvsst_ss0p81v125c ts28nmhspst_ss0p81v125c ts28nmhlpst_ss0p81v125c"

# MinLibFile --- The name of the file containing the min synthesis library.
-min_lib_file "ts28nmhssst_ff0p99v125c.db ts28nmhlsst_ff0p99v125c.db ts28nmhvsst_ff0p99v125c.db ts28nmhspst_ff0p99v125c.db ts28nmhlpst_ff0p99v125c.db"

# MinLibName --- The name of the min synthesis library.
-min_lib_name "ts28nmhssst_ff0p99v125c ts28nmhlsst_ff0p99v125c ts28nmhvsst_ff0p99v125c ts28nmhspst_ff0p99v125c ts28nmhlpst_ff0p99v125c"

# TypLibFile --- The name of the file containing the typical synthesis library.
-typ_lib_file "ts28nmhssst_tt0p9v25c.db ts28nmhlsst_tt0p9v25c.db ts28nmhvsst_tt0p9v25c.db ts28nmhspst_tt0p9v25c.db ts28nmhlpst_tt0p9v25c.db"

# TypLibName --- The name of the typical synthesis library.
-typ_lib_name "ts28nmhssst_tt0p9v25c ts28nmhlsst_tt0p9v25c ts28nmhvsst_tt0p9v25c ts28nmhspst_tt0p9v25c ts28nmhlpst_tt0p9v25c"

# SynOperatingCon --- The synthesis operating conditions.
-syn_operating_con SS0P81V125C

# PtSlowOpCons --- The operating conditions to be used for worst case static timing analysis
-pt_slow_op_cons SS0P81V125C

# PtFastOpCons --- The operating conditions to be used for best case static timing analysis.
-pt_fast_op_cons FF0P99V125C

# PtTypicalOpCons --- The operating conditions to be used for typical case static timing analysis.
-pt_typical_op_cons TT0P9V25C

# PtStaCons --- The conditions used for static timing analysis
-ptstacons ocv

# PhysLibPath --- The path to the Synopsys physical synthesis libraries.
-phys_lib_path ""

# PhysLib --- The Synopsys physical synthesis library name.
-phys_lib ""

# DataBasePath --- The path and name of the 'map file' located at the top level of the DataBase containing the pre-compiled Vendor RAM models and wrapper files.
-data_base_path arcrams_lib/map_file.txt

# CapTable --- File containing lookup tables for fast estimation of parasitics in Cadence's FirstEncounter tool
-cap_table /remote/arc/arc6000/libext/iclibs/TSMC45/PcC040LP_CRN45SHRINK_7M4X0Y2Z0UPDK/0.2/tools/cadence_soc/7.1/C040LP_CRN45SHRINK_7M4X0Y2Z0U_GXL_LP_typical.capTable

# BufFootprint --- The names of the footprints in the library that represent buffers]
-buf_footprint SST_BUF

# InvFootprint --- The names of the footprints in the library that represent inverters
-inv_footprint SST_INV

# DelFootprint --- The names of the footprints in the library that represent delay cells
-del_footprint SST_DEL

# ClockBufferCells --- A list of buffers and inverters in the library that may be used in the construction of a clock tree
-clock_buffers "STV_BUF_S_1 STV_BUF_S_1P25 STV_BUF_S_1P5 STV_BUF_S_2 STV_BUF_S_2P5 STV_BUF_S_3 STV_BUF_S_4 STV_BUF_S_5 STV_BUF_S_6 STV_BUF_S_8 STV_BUF_S_10 STV_BUF_S_12 STV_BUF_S_14 STV_BUF_S_16 STV_BUF_S_18 STV_BUF_S_20 STV_BUF_S_24 STV_BUF_S_32 STV_INV_S_0P5 STV_INV_S_0P65 STV_INV_S_0P8 STV_INV_S_1 STV_INV_S_1P25 STV_INV_S_1P5 STV_INV_S_2 STV_INV_S_2P25 STV_INV_S_2P5 STV_INV_S_3 STV_INV_S_3P75 STV_INV_S_4 STV_INV_S_5 STV_INV_S_6 STV_INV_S_7 STV_INV_S_8 STV_INV_S_9 STV_INV_S_10 STV_INV_S_11 STV_INV_S_12 STV_INV_S_13 STV_INV_S_14 STV_INV_S_16 STV_INV_S_20 STV_INV_S_24 STV_INV_S_32"

# ClockTransition --- The maximum transition time allowed on clock nets
-clock_transition 300

# QxTechnology --- Technology file for Cadence's 3D extraction engine, QX
-qx_techfile /remote/arc/arc6000/libext/iclibs/TSMC45/PcC040LP_CRN45SHRINK_7M4X0Y2Z0UPDK/0.2/tools/cadence_ext/7.1.2/GXL/LP/GXL_LP_rcworst/qrcTechFile

# QxLibrary --- The location of the QX library data
-qx_library /remote/arc/arc6000/libext/iclibs/TSMC45/PcC045LP_CRN45_7M4X0Y2Z0UPDK/1.1.1/tools/cadence_anls/xtc

# RAMWePolarity --- Defines the polarity of the write enable signals for all RAMs in the ARC700.
-ram_we_polarity 1

# RAMCkPolarity --- Defines the polarity of the clock enable signals for all RAMs in the ARC700.
-ram_ck_polarity 1

# VolcanoLibrary --- The location of the volcano library data
-volcano ""

# VolcanoLibraryName --- The name of the library contained in the volcano
-volcano_name ""

# MilkywayTechFile --- The path to the technology file for milkyway libraries
-mw_tech_file /slowfs/de02dwt2p038/HighSpeed/ts28nmhssst/latest/milkyway/tf/ts28nmhssst_m08f0f2f0_UTRDL.tf

# MilkywaySearchPath --- A comma separated list of directories to use when searching for milkyway libraries
-mw_search_path "/slowfs/de02dwt2p038/HighSpeed/ts28nmhssst/latest/milkyway /slowfs/de02dwt2p038/HighSpeed/ts28nmhlsst/latest/milkyway /slowfs/de02dwt2p038/HighSpeed/ts28nmhvsst/latest/milkyway /slowfs/de02dwt2p038/HighSpeed/ts28nmhspst/latest/milkyway /slowfs/de02dwt2p038/HighSpeed/ts28nmhlpst/latest/milkyway"

# MilkywayCellLibraries --- A comma separated list of milkyway databases to be found on the search path
-mw_cell_libs "/slowfs/de02dwt2p038/HighSpeed/ts28nmhssst/latest/milkyway/ts28nmhssst_m10f2f0f2_RDL /slowfs/de02dwt2p038/HighSpeed/ts28nmhlsst/latest/milkyway/ts28nmhlsst_m10f2f0f2_RDL /slowfs/de02dwt2p038/HighSpeed/ts28nmhvsst/latest/milkyway/ts28nmhvsst_m10f2f0f2_RDL /slowfs/de02dwt2p038/HighSpeed/ts28nmhspst/latest/milkyway/ts28nmhspst_m10f2f0f2_RDL /slowfs/de02dwt2p038/HighSpeed/ts28nmhlpst/latest/milkyway/ts28nmhlpst_m10f2f0f2_RDL"

# TLUPlusMaxFile --- The TLU+ file which contains the parameters for max extraction
-tluplus_max_file /slowfs/de02dwt2p038/Gen2_libs/tsmc_tech/milkyway/tlup/cln28hpm_1p08m+ut-alrdl_5x2z_cworst.tlup

# TLUPlusMinFile --- The TLU+ file which contains the parameters for min extraction
-tluplus_min_file /slowfs/de02dwt2p038/Gen2_libs/tsmc_tech/milkyway/tlup/cln28hpm_1p08m+ut-alrdl_5x2z_cbest.tlup

# TLUMapFile --- The TLU+ map file to map layers names to the Milkyway layer names
-tluplus_map_file /slowfs/de02dwt2p038/HighSpeed/ts28nmhssst/latest/milkyway/tlup/layers.map

# min_NXTGRD --- The NXTGRD file which contains the parameters for min extraction
-min_nxtgrd /slowfs/de02dwt2p038/Gen2_libs/tsmc_tech/StarRC-UT-ALRDL/cln28hpm_1p08m+ut-alrdl_5x2z_cbest.nxtgrd

# max_NXTGRD --- The NXTGRD file which contains the parameters for max extraction
-max_nxtgrd /slowfs/de02dwt2p038/Gen2_libs/tsmc_tech/StarRC-UT-ALRDL/cln28hpm_1p08m+ut-alrdl_5x2z_cworst.nxtgrd

# ClockGatingCell --- Name of clock gating cell to be used as architectural clock gate
-clock_gating_cell STV_CKGTPLT_V5_1

# DecapCells --- list of decap cells for this library
-decap_cells "STN_DCAP_16 STN_DCAP_12 STN_DCAP_8 STN_DCAP_6 STN_DCAP_4"

# FillerCells --- list of filler cells for this library
-filler_cells "{STN_FILL256 STN_FILL128 STN_FILL64 STN_FILL32 STN_FILL16 STN_FILL12 STN_FILL8 STN_FILL6 STN_FILL5 STN_FILL4 STN_FILL3 STN_FILL2 STN_FILL1}  {STL_FILL256 STL_FILL128 STL_FILL64 STL_FILL32 STL_FILL16 STL_FILL12 STL_FILL8 STL_FILL6 STL_FILL5 STL_FILL4 STL_FILL3 STL_FILL2 STL_FILL1}  {STV_FILL256 STV_FILL128 STV_FILL64 STV_FILL32 STV_FILL16 STV_FILL12 STV_FILL8 STV_FILL6 STV_FILL5 STV_FILL4 STV_FILL3 STV_FILL2 STV_FILL1}  "

# AntDiodeCells --- list of antenna diode protection cells for this library
-ant_diode_cells STN_TIEDIN_1

# MinWellTapDistance --- Minimum required distance between well-tap cells ( in microns ) 
-min_nwell_tap_distance 110

# NwellTapCell --- Name of nwell tap cell to be used
-nwell_tap_cell STN_TAPDS

# NwellAoTapCell --- Name of nwell always-on tap cell to be used
-nwell_ao_tap_cell PTP_TAPPP

# EndCapCellLeft --- Name of end cap cells to be used at left side of row
-end_cap_cell_left STN_CAPLR4

# EndCapCellRight --- Name of end cap cells to be used at  right tside of row
-end_cap_cell_right STN_CAPLR4

# GdsLayerMapFile --- Name of file mapping layers names to GDS2 layer numbers
-gds_layer_map_file /slowfs/de02dwt2p038/HighSpeed/ts28nmhssst/latest/milkyway/tf/gds2.map_m08f0f2f0_UTRDL

# MetalFillDeck --- Name of file ICV/Hercules deck for doing metal fill on GDS2 view
-metal_fill_deck ""

# AntRuleDeck --- Name of file ICV/Hercules deck for doing Antenna rule checking
-ant_rule_deck /slowfs/de02dwt2p038/Gen2_libs/tsmc_tech/ICV/ANTENNA_DRC/ICVN28HP_8M.ANT_002.13c

# DrcRuleDeck --- Name of file ICV/Hercules deck for doing DRC checking
-drc_rule_deck /slowfs/de02dwt2p038/Gen2_libs/tsmc_tech/ICV/LOGIC_TopMz_DRC/ICVN28HP_8M_5X2Z_002.13c.encrypt

# LvsRuleDeck --- Name of file ICV/Hercules deck for doing LVS checking
-lvs_rule_deck ""

# AntRuleFile --- Name of file TCL rule file for doing Antenna fixing
-ant_rule_file /slowfs/de02dwt2p038/HighSpeed/ts28nmhssst/latest/milkyway/antenna/antenna_rule_db_update_m08f0f2f0_UTRDL.tcl

# EmRuleFile --- Name of file ALF rule file for doing ElectoMigration Analysis
-em_rule_file /slowfs/de02dwt2p038/HighSpeed/ts28nmhssst/latest/milkyway/alf/ts28nmhssst_m08f0f2f0_UTRDL.alf

# DblViaOrderFile --- Name of file with foundry-preferred order of doubled vias when doing via doubling
-dbl_via_order_file /slowfs/de02dwt2p038/HighSpeed/ts28nmhssst/latest/demo/pnr/ICC/cmds/ts28.rvi.map

# IcgCellCkPinName --- Name of clock input pin on integrated clock gating cell
-icgcell_ck_pin_name CK

# IcgCellQPinName --- Name of gated clock output pin name on integrated clock gating cell
-icgcell_q_pin_name Q

# IcgCellFEPinName --- Name of functional enanble input pin name on integrated clock gating cell
-icgcell_fe_pin_name EN

# IcgCellTEPinName --- Name of test enanble input pin name on integrated clock gating cell
-icgcell_te_pin_name SE

# SupplyVolt_wc --- Worst-case operating voltage
-supply_volt_wc 0.81

# IsoCellClampHigh --- Isolation cell clamp high
-iso_cell_clamp_high "PTP_ISOS0CL1_* PTQ_ISOS0CL1_*"

# IsoCellClampLow --- Isolation cell clamp low
-iso_cell_clamp_low "PTP_ISOS1CL0_* PTQ_ISOS1CL0_*"

# PwrSwitchCell --- Header fine grain power switch cell name
-power_switch_cell PTQ_PGATDRV_CO_10

# PwrSwitchCellResWc --- Worst case power switch cell resistance
-power_switch_cell_res_wc 233.4

# PwrSwitchCellPinLayers --- Primary and secondary (=always on and gated) power pins and associated layer names
-power_switch_cell_pin_layers "VDDP M2 VDDC M2"

# SupplyVoltULP_wc --- Worst-case ultra low power operating voltage for std cell parts
-supply_volt_ulp_wc 0.63

# LSCellHigh2Low --- Level shifter cell from high to low voltage domain
-ls_cell_high_2_low "PTP_LVLDBUF_DP_* PTP_LVLDBUF_D_* PTQ_LVLDBUF_DP_* PTQ_LVLDBUF_D_*"

# LSCellLow2High --- level shifter cell from low to high voltage domain
-ls_cell_low_2_high "PTP_LVLDBUF_PU_* PTP_LVLDBUF_U_* PTP_LVLDBUF_PY2_* PTP_LVLDBUF_Y2_* PTQ_LVLDBUF_PU_* PTQ_LVLDBUF_U_* PTQ_LVLDBUF_PY2_* PTQ_LVLDBUF_Y2_*"


######## SynopsysEmbeditIntegratorFlow --- com.synopsys.SynopsysEmbeditIntegratorFlow.1_0 ########

# Create SynopsysEmbeditIntegratorFlow
-create com.synopsys.SynopsysEmbeditIntegratorFlow.1_0 System.SynopsysEmbeditIntegratorFlow

# SynopsysEmbeditIntegratorFlow --- Add the Synopsys Embedit Integrator Flow Component
-seif true

# OptimizationStrategy --- area : smallest memory instances, performance : fastest instances
-optimization_strategy performance

# OptimizationStrategyScope --- global: all memories get selected based on criteria specified in Optimization Strategy option, per_memory: criteria is specified per memory
-optimization_strategy_scope global

# io_i3c0CompilerPath --- Path to the io_i3c0 Memory Compiler (EM, DFSS family
-io_i3c0_compiler_path ""

# io_i3c0OptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-io_i3c0_optimization_strategy performance

# io_i3c0HandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-io_i3c0_hand_picked_instance ""

# io_i3c1CompilerPath --- Path to the io_i3c1 Memory Compiler (EM, DFSS family
-io_i3c1_compiler_path ""

# io_i3c1OptimizationStrategy --- area : smallest memory instances, performance : fastest instances : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-io_i3c1_optimization_strategy performance

# io_i3c1HandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-io_i3c1_hand_picked_instance ""

# io_i3c2CompilerPath --- Path to the io_i3c2 Memory Compiler (EM, DFSS family
-io_i3c2_compiler_path ""

# io_i3c2OptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-io_i3c2_optimization_strategy performance

# io_i3c2HandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-io_i3c2_hand_picked_instance ""

# io_i3c3CompilerPath --- Path to the io_i3c3 Memory Compiler (EM, DFSS family
-io_i3c3_compiler_path ""

# io_i3c3OptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-io_i3c3_optimization_strategy performance

# io_i3c3HandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-io_i3c3_hand_picked_instance ""

# dss_semc_aicCompilerPath --- Path to the dss_semc_aic (Secure External Memory Controller Authenticated I$ Memory Compiler (EM, DSS family
-dss_semc_aic_compiler_path ""

# dss_semc_aicOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-dss_semc_aic_optimization_strategy performance

# dss_semc_aicHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-dss_semc_aic_hand_picked_instance ""

# dss_semc_adcCompilerPath --- Path to the dss_semc_adc (Secure External Memory Controller Authenticated D$ Memory Compiler (EM, DSS family
-dss_semc_adc_compiler_path ""

# dss_semc_adcOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-dss_semc_adc_optimization_strategy performance

# dss_semc_adcHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-dss_semc_adc_hand_picked_instance ""

# dss_semc_adc_elp_adc_lseqCompilerPath --- Path to the dss_semc_adc_elp_adc_lseq (Secure External Memory Controller Authenticated D$ Memory Compiler (EM, DSS family
-dss_semc_adc_elp_adc_lseq_compiler_path ""

# dss_semc_adc_elp_adc_lseqOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-dss_semc_adc_elp_adc_lseq_optimization_strategy performance

# dss_semc_adc_elp_adc_lseqHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-dss_semc_adc_elp_adc_lseq_hand_picked_instance ""

# ICCMCompilerPath --- Path to the ICCM Memory Compiler (EM, ARC600, ARC700 family
-iccm_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# ICCMOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-iccm_optimization_strategy performance

# ICCMHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-iccm_hand_picked_instance ""

# ICCM0CompilerPath --- Path to the ICCM0 Memory Compiler (HS family)
-iccm0_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# ICCM0OptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-iccm0_optimization_strategy performance

# ICCM0HandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-iccm0_hand_picked_instance ""

# ICCM1CompilerPath --- Path to the ICCM1 Memory Compiler (EM and HS family)
-iccm1_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# ICCM1OptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-iccm1_optimization_strategy performance

# ICCM1HandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-iccm1_hand_picked_instance ""

# DCCMCompilerPath --- Path to the DCCM Memory Compiler (EM, HS, ARC600, ARC700 family)
-dccm_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# DCCMOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-dccm_optimization_strategy performance

# DCCMHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-dccm_hand_picked_instance ""

# XYCCMCompilerPath --- Path to the XYCCM Memory Compiler (EM core family only)
-xyccm_compiler_path ""

# XYCCMOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-xyccm_optimization_strategy performance

# XYCCMHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-xyccm_hand_picked_instance ""

# ICacheTagCompilerPath --- Path to the ICacheTag Memory Compiler (EM, HS, ARC600, ARC700 family) 
-icache_tag_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# ICacheTagOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-icache_tag_optimization_strategy performance

# ICacheTagHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-icache_tag_hand_picked_instance ""

# DCacheTagCompilerPath --- Path to the DCacheTag Memory Compiler (EM, HS, ARC600, ARC700 family)
-dcache_tag_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# DCacheTagOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-dcache_tag_optimization_strategy performance

# DCacheTagHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-dcache_tag_hand_picked_instance ""

# ICacheDataCompilerPath --- Path to the ICacheData Memory Compiler  (EM, HS, ARC600, ARC700 family)
-icache_data_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# ICacheDataOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-icache_data_optimization_strategy performance

# ICacheDataHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-icache_data_hand_picked_instance ""

# DCacheDataCompilerPath --- Path to the DCacheData Memory Compiler  (EM, HS, ARC600, ARC700 family)
-dcache_data_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# DCacheDataOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-dcache_data_optimization_strategy performance

# DCacheDataHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-dcache_data_hand_picked_instance ""

# DCacheCoherencyCompilerPath --- Path to the DCacheCoherency Memory Compiler(HS family only) 
-dcache_coherency_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# DCacheCoherencyOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-dcache_coherency_optimization_strategy performance

# DCacheCoherencyHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-dcache_coherency_hand_picked_instance ""

# SmartCompilerPath --- Path to the Smart Memory Compiler  (EM, HS, ARC600, ARC700 family)
-smart_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# SmartOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-smart_optimization_strategy performance

# SmartHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-smart_hand_picked_instance ""

# VecMemCompilerPath --- Path to the HS  Vector Unit  RAM Memory Compiler(HS family only)
-vec_mem_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sadul02msa+

# VecMemOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-vec_mem_optimization_strategy performance

# VecMemHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-vec_mem_hand_picked_instance ""

# CNNDataRamCompilerPath --- Path to the CNN data ram Memory Compiler (CNN only)
-cnn_data_compiler_path ""

# CNNDataRamOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-cnn_data_optimization_strategy performance

# CNNDataRamHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-cnn_data_hand_picked_instance ""

# CNNProgRamCompilerPath --- Path to the CNN program ram Memory Compiler (CNN only)
-cnn_prog_compiler_path ""

# CNNProgRamOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-cnn_prog_optimization_strategy performance

# CNNProgRamHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-cnn_prog_hand_picked_instance ""

# CNN2ProgRamCCompilerPath --- Path to the CNN2 program ram (in TNNc) Memory Compiler (CNN2 only)
-cnn2_prog_c_compiler_path ""

# CNN2ProgRamCOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-cnn2_prog_c_optimization_strategy performance

# CNN2ProgCRamHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-cnn2_prog_c_hand_picked_instance ""

# CNN2DataRamCCompilerPath --- Path to the CNN2 data ram (in TNNc)  Memory Compiler (CNN2 only)
-cnn2_data_c_compiler_path ""

# CNN2DataRamCOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-cnn2_data_c_optimization_strategy performance

# CNN2DataRamCHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-cnn2_data_c_hand_picked_instance ""

# CNN2BlkAccCCompilerPath --- Path to the CNN2  Block accumulator memory (in TNNc)  2-port Memory Compiler (CNN2 only)
-cnn2_blk_acc_c_compiler_path ""

# CNN2BlkAccCOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-cnn2_blk_acc_c_optimization_strategy performance

# CNN2BlkAccCHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph42p11sadul01ms01_64x128_cm8_bk1_cdfalse_bwe1_bno_rno
-cnn2_blk_acc_c_hand_picked_instance ""

# CNN2ProgRamVCompilerPath --- Path to the CNN2 program ram (in TNNv) Memory Compiler (CNN2 only)
-cnn2_prog_v_compiler_path ""

# CNN2ProgRamVOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-cnn2_prog_v_optimization_strategy performance

# CNN2ProgVRamHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-cnn2_prog_v_hand_picked_instance ""

# CNN2DataRamVCompilerPath --- Path to the CNN2 data ram (in TNNv)  Memory Compiler (CNN2 only)
-cnn2_data_v_compiler_path ""

# CNN2DataRamVOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-cnn2_data_v_optimization_strategy performance

# CNN2DataRamVHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-cnn2_data_v_hand_picked_instance ""

# CNN2MemArmCompilerPath --- Path to the CNN2  AXI2AXI reordering memory (in TNNv)  2-port Memory Compiler (CNN2 only)
-cnn2_mem_arm_compiler_path ""

# CNN2MemArmOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-cnn2_mem_arm_optimization_strategy performance

# CNN2MemArmHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph42p11sadul01ms01_256x256_cm8_bk1_cdfalse_bwe1_bno_rno
-cnn2_mem_arm_hand_picked_instance ""

# CNN2MemAccVCompilerPath --- Path to the CNN2  accumulator memory (in TNNv)  2-port Memory Compiler (CNN2 only)
-cnn2_mem_acc_v_compiler_path ""

# CNN2MemAccVOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-cnn2_mem_acc_v_optimization_strategy performance

# CNN2MemAccVHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph42p11sadul01ms01_256x256_cm8_bk1_cdfalse_bwe1_bno_rno
-cnn2_mem_acc_v_hand_picked_instance ""

# CNN3VecBankCompilerPath --- Path to the CNN3 Vector Bank  Memory Compiler (CNN3 only)
-cnn3_vec_bank_compiler_path ""

# CNN3VecBankOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-cnn3_vec_bank_optimization_strategy performance

# CNN3VecBankHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-cnn3_vec_bank_hand_picked_instance ""

# CNN2VecBankCompilerPath --- Path to the CNN2 Vector Bank  Memory Compiler (CNN2 only)
-cnn2_vec_bank_compiler_path ""

# CNN2VecBankOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-cnn2_vec_bank_optimization_strategy performance

# CNN2VecBankHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-cnn2_vec_bank_hand_picked_instance ""

# CNN2WeightBankCompilerPath --- Path to the CNN2 Weight Bank  Memory Compiler (CNN2 only)
-cnn2_weight_bank_compiler_path ""

# CNN2WeightBankOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-cnn2_weight_bank_optimization_strategy performance

# CNN2WeightBankHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-cnn2_weight_bank_hand_picked_instance ""

# MCIPMsgCompilerPath --- Path to the ARConnect msg ram Memory Compiler (ARConnect only)
-mcip_msg_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# MCIPMsgOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-mcip_msg_optimization_strategy performance

# MCIPMsgHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-mcip_msg_hand_picked_instance ""

# LlmCompilerPath --- Path to the Cluster Shared Memory  Compiler (aka LLM) 
-llm_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# LlmOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-llm_optimization_strategy performance

# LlmHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-llm_hand_picked_instance ""

# LlmP0CompilerPath --- Path to the Cluster Shared Memory  Compiler for Partition0 (aka LLM) 
-llm_partition0_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# LlmP0OptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-llm_partition0_optimization_strategy performance

# LlmP0HandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-llm_partition0_hand_picked_instance ""

# LlmP1CompilerPath --- Path to the Cluster Shared Memory  Compiler for Partition1 (aka LLM) 
-llm_partition1_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# LlmP1OptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-llm_partition1_optimization_strategy performance

# LlmP1HandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-llm_partition1_hand_picked_instance ""

# XYMemCompilerPath --- Path to the XY Memory Compiler (ARC600 family only)
-xymem_compiler_path ""

# XYMemOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-xymem_optimization_strategy performance

# XYMemHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-xymem_hand_picked_instance ""

# RegisterFileCompilerPath --- Path to the RegisterFile Compiler (EM, ARC600, ARC700 family)
-regfile_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh42p11sadrl128s+

# RegisterFileOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-regfile_optimization_strategy performance

# RegisterFileHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-regfile_hand_picked_instance ""

# MMUCompilerPath --- Path to the MMU Memory Compiler (ARC700 and HS family)
-mmu_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# MMUOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-mmu_optimization_strategy performance

# MMUHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-mmu_hand_picked_instance ""

# DCacheDirtyCompilerPath --- Path to the DCacheDirty Memory Compiler (ARC700 family only) 
-dcache_dirty_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh42p11sadrl128s+

# DCacheDirtyOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-dcache_dirty_optimization_strategy performance

# DCacheDirtyHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-dcache_dirty_hand_picked_instance ""

# BPUBTACCompilerPath --- Path to the BPU BTAC Memory Compiler  (ARC700 family only) 
-bpubtac_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh42p11sadrl128s+

# BPUBTACOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-bpubtac_optimization_strategy performance

# BPUBTACHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-bpubtac_hand_picked_instance ""

# BranchCacheCompilerPath --- Path to the Branch Cache Memory Compiler  (HS family only) 
-branch_cache_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# BranchCacheOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-branch_cache_optimization_strategy performance

# BranchCacheHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-branch_cache_hand_picked_instance ""

# PredictionTableCompilerPath --- Path to the Prediction Table Memory Compiler (HS family only)
-prediction_table_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# PredictionTableOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-prediction_table_optimization_strategy performance

# PredictionTableHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-prediction_table_hand_picked_instance ""

# WriteBufferMemCompilerPath --- Path to the Write Buffer Mem Memory Compiler (HS family only)
-wb_mem_compiler_path ""

# WriteBufferMemOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-wb_mem_optimization_strategy performance

# WriteBufferMemHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-wb_mem_hand_picked_instance ""

# CdmaDescriptorCompilerPath --- Path to the Cluster DMA  Descriptor Memory Compiler (HS family only)
-dma_descr_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# CdmaDescriptorOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-dma_descr_optimization_strategy performance

# CdmaDescriptorHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-dma_descr_hand_picked_instance ""

# CdmaBufferCompilerPath --- Path to the Cluster DMA  Data Buffer 2-port Memory Compiler (HS family only)
-dma_buf_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh42p11sadrl128s*

# CdmaBufferOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-dma_buf_optimization_strategy performance

# CdmaBufferHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-dma_buf_hand_picked_instance ""

# WriteBufferPer0CompilerPath --- Path to the Write Buffer Per0 Memory Compiler (HS family only)
-wb_per0_compiler_path ""

# WriteBufferPer0OptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-wb_per0_optimization_strategy performance

# WriteBufferPer0HandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-wb_per0_hand_picked_instance ""

# WriteBufferPer1CompilerPath --- Path to the Write Buffer Per1 Memory Compiler (HS family only)
-wb_per1_compiler_path ""

# WriteBufferPer1OptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-wb_per1_optimization_strategy performance

# WriteBufferPer1HandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-wb_per1_hand_picked_instance ""

# MEPixelCacheCompilerPath --- Path to the ME Pixel Cache Memory Compiler  (ARC700 family only)
-mepixelcache_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# MEPixelCacheOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-mepixelcache_optimization_strategy performance

# MEPixelCacheHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-mepixelcache_hand_picked_instance ""

# SIMDCodeMemCompilerPath --- Path to the SIMD Code Memory Compiler  (ARC700 family only)
-simdcodemem_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# SIMDCodeMemOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-simdcodemem_optimization_strategy performance

# SIMDCodeMemHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-simdcodemem_hand_picked_instance ""

# SIMDCodeQueueCompilerPath --- Path to the SIMD Code Queue Memory Compiler  (ARC700 family only)
-simdcodequeue_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sasrl128sa+

# SIMDCodeQueueOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-simdcodequeue_optimization_strategy performance

# SIMDCodeQueueHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-simdcodequeue_hand_picked_instance ""

# SIMDMemCompilerPath --- Path to the SIMD Memory Compiler  (ARC700 family only)
-simdmem_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# SIMDMemOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-simdmem_optimization_strategy performance

# SIMDMemHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-simdmem_hand_picked_instance ""

# RTTIntMemCompilerPath --- Path to the RTT intmem Memory Compiler
-rtt_int_mem_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh42p11sadgl128s+

# RTTIntMemOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_int_mem_optimization_strategy performance

# RTTIntMemHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_int_mem_hand_picked_instance ""

# RTTDSMCompilerPath --- Path to the RTT DSM Source Buffer Memory Compiler
-rtt_dsm_sbuf_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh42p11sadul01ms+

# RTTDSMOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_dsm_sbuf_optimization_strategy performance

# RTTDSMHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_dsm_sbuf_hand_picked_instance ""

# RTTPCMMemCompilerPath --- Path to the RTT PCM Source Buffer Memory Compiler
-rtt_pcm_sbuf_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh42p11sadul01ms+

# RTTPCMMemOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_pcm_sbuf_optimization_strategy performance

# RTTPCMMemHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_pcm_sbuf_hand_picked_instance ""

# RTTPTCMMemCompilerPath --- Path to the RTT PTCM Source Buffer Memory Compiler
-rtt_ptcm_buf_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh42p11sadul01ms+

# RTTPTCMMemOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_ptcm_sbuf_optimization_strategy performance

# RTTPTCMMemHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_ptcm_sbuf_hand_picked_instance ""

# RTTPTMMemCompilerPath --- Path to the RTT PTM Source Buffer Memory Compiler
-rtt_ptm_sbuf_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh42p11sadul01ms+

# RTTPTMMemOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_ptm_sbuf_optimization_strategy performance

# RTTPTMMemHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_ptm_sbuf_hand_picked_instance ""

# RTTDTMMemCompilerPath --- Path to the RTT DTM Source Buffer Memory Compiler
-rtt_dtm_sbuf_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh42p11sadul01ms+

# RTTDTMMemOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_dtm_sbuf_optimization_strategy performance

# RTTDTMMemHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_dtm_sbuf_hand_picked_instance ""

# RTTCRMMemCompilerPath --- Path to the RTT CRM Source Buffer Memory Compiler
-rtt_crm_sbuf_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh42p11sadul01ms+

# RTTCRMMemOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_crm_sbuf_optimization_strategy performance

# RTTCRMMemHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_crm_sbuf_hand_picked_instance ""

# RTTAUXMMemCompilerPath --- Path to the RTT AUXM Source Buffer Memory Compiler
-rtt_auxm_sbuf_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh42p11sadul01ms+

# RTTAUXMMemOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_auxm_sbuf_optimization_strategy performance

# RTTAUXMMemHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_auxm_sbuf_hand_picked_instance ""

# RTTERRMMemCompilerPath --- Path to the RTT ERRM Source Buffer Memory Compiler
-rtt_errm_sbuf_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh42p11sadul01ms+

# RTTERRMMemOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_errm_sbuf_optimization_strategy performance

# RTTERRMMemHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_errm_sbuf_hand_picked_instance ""

# RTTOTMMemCompilerPath --- Path to the RTT OTM Source Buffer Memory Compiler
-rtt_otm_sbuf_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh42p11sadul01ms+

# RTTOTMMemOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_otm_sbuf_optimization_strategy performance

# RTTOTMMemHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_otm_sbuf_hand_picked_instance ""

# RTTRFMMemCompilerPath --- Path to the RTT RFM Source Buffer Memory Compiler
-rtt_rfm_sbuf_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh42p11sadul01ms+

# RTTRFMMemOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_rfm_sbuf_optimization_strategy performance

# RTTRFMMemHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_rfm_sbuf_hand_picked_instance ""

# RTTPBUFMemCompilerPath --- Path to the RTT PBUF Memory Compiler
-rtt_pbuf_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh42p11sadul01ms+

# RTTPBUFMemOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_pbuf_optimization_strategy performance

# RTTPBUFMemHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_pbuf_hand_picked_instance ""

# RTTWPMMemCompilerPath --- Path to the RTT WPM Source Buffer Memory Compiler
-rtt_wpm_sbuf_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh42p11sadul01ms+

# RTTWPMMemOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_pbuf_sbuf_optimization_strategy performance

# RTTWPMMemHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_wpm_sbuf_hand_picked_instance ""

# RTTWDATAMemCompilerPath --- Path to the RTT Bus Master Buffer Memory Compiler
-rtt_bus_master_buf_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh42p11sadgl128s+

# RTTWDATAMemOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_bus_master_buf_optimization_strategy performance

# RTTWDATAMemHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_bus_master_buf_hand_picked_instance ""

# RTTIntMemCompilerPath_1p --- Path to the RTT intmem 1-port Memory Compiler
-rtt_int_mem_1p_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# RTTIntMemOptimizationStrategy_1p --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_int_mem_1p_optimization_strategy performance

# RTTIntMemHandPicked_1p --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_int_mem_1p_hand_picked_instance ""

# RTTDSMCompilerPath_1p --- Path to the RTT DSM Source Buffer  1-port Memory Compiler
-rtt_dsm_sbuf_1p_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# RTTDSMOptimizationStrategy_1p --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_dsm_sbuf_1p_optimization_strategy performance

# RTTDSMHandPicked_1p --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_dsm_sbuf_1p_hand_picked_instance ""

# RTTPCMMemCompilerPath_1p --- Path to the RTT PCM Source Buffer  1-port Memory Compiler
-rtt_pcm_sbuf_1p_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# RTTPCMMemOptimizationStrategy_1p --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_pcm_sbuf_1p_optimization_strategy performance

# RTTPCMMemHandPicked_1p --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_pcm_sbuf_1p_hand_picked_instance ""

# RTTPTCMMemCompilerPath_1p --- Path to the RTT PTCM Source Buffer 1-port  Memory Compiler
-rtt_ptcm_buf_1p_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# RTTPTCMMemOptimizationStrategy_1p --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_ptcm_sbuf_1p_optimization_strategy performance

# RTTPTCMMemHandPicked_1p --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_ptcm_sbuf_1p_hand_picked_instance ""

# RTTPTMMemCompilerPath_1p --- Path to the RTT PTM Source Buffer  1-port Memory Compiler
-rtt_ptm_sbuf_1p_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# RTTPTMMemOptimizationStrategy_1p --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_ptm_sbuf_1p_optimization_strategy performance

# RTTPTMMemHandPicked_1p --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_ptm_sbuf_1p_hand_picked_instance ""

# RTTDTMMemCompilerPath_1p --- Path to the RTT DTM Source Buffer  1-port Memory Compiler
-rtt_dtm_sbuf_1p_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# RTTDTMMemOptimizationStrategy_1p --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_dtm_sbuf_1p_optimization_strategy performance

# RTTDTMMemHandPicked_1p --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_dtm_sbuf_1p_hand_picked_instance ""

# RTTCRMMemCompilerPath_1p --- Path to the RTT CRM Source 1-port Buffer Memory Compiler
-rtt_crm_sbuf_1p_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# RTTCRMMemOptimizationStrategy_1p --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_crm_sbuf_1p_optimization_strategy performance

# RTTCRMMemHandPicked_1p --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_crm_sbuf_1p_hand_picked_instance ""

# RTTAUXMMemCompilerPath_1p --- Path to the RTT AUXM Source 1-port Buffer Memory Compiler
-rtt_auxm_sbuf_1p_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# RTTAUXMMemOptimizationStrategy_1p --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_auxm_sbuf_1p_optimization_strategy performance

# RTTAUXMMemHandPicked_1p --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_auxm_sbuf_1p_hand_picked_instance ""

# RTTERRMMemCompilerPath_1p --- Path to the RTT ERRM Source Buffer 1-port Memory Compiler
-rtt_errm_sbuf_1p_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# RTTERRMMemOptimizationStrategy_1p --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_errm_sbuf_1p_optimization_strategy performance

# RTTERRMMemHandPicked_1p --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_errm_sbuf_1p_hand_picked_instance ""

# RTTOTMMemCompilerPath_1p --- Path to the RTT OTM Source Buffer 1-port  Memory Compiler
-rtt_otm_sbuf_1p_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# RTTOTMMemOptimizationStrategy_1p --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_otm_sbuf_1p_optimization_strategy performance

# RTTOTMMemHandPicked_1p --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_otm_sbuf_1p_hand_picked_instance ""

# RTTRFMMemCompilerPath_1p --- Path to the RTT RFM Source Buffer 1-port  Memory Compiler
-rtt_rfm_sbuf_1p_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# RTTRFMMemOptimizationStrategy_1p --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_rfm_sbuf_1p_optimization_strategy performance

# RTTRFMMemHandPicked_1p --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_rfm_sbuf_1p_hand_picked_instance ""

# RTTPBUFMemCompilerPath_1p --- Path to the RTT PBUF 1-port  Memory Compiler
-rtt_pbuf_1p_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# RTTPBUFMemOptimizationStrategy_1p --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_pbuf_1p_optimization_strategy performance

# RTTPBUFMemHandPicked_1p --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_pbuf_1p_hand_picked_instance ""

# RTTWPMMemCompilerPath_1p --- Path to the RTT WPM Source Buffer 1-port  Memory Compiler
-rtt_wpm_sbuf_1p_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# RTTWPMMemOptimizationStrategy_1p --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_wpm_sbuf_1p_optimization_strategy performance

# RTTWPMMemHandPicked_1p --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_wpm_sbuf_1p_hand_picked_instance ""

# RTTWDATAMemCompilerPath_1p --- Path to the RTT Bus Master Buffer 1-port Memory Compiler
-rtt_bus_master_buf_1p_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# RTTWDATAMemOptimizationStrategy_1p --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_bus_master_buf_1p_optimization_strategy performance

# RTTWDATAMemHandPicked_1p --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-rtt_bus_master_buf_1p_hand_picked_instance ""

# SMDataCompilerPath --- Path to the SLC Shared Data Memory Compiler
-sm_data_compiler_path ""

# SMDataOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-sm_data_optimization_strategy performance

# SMDataHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-sm_data_hand_picked_instance ""

# SMData1CompilerPath --- Path to the SLC Shared Data1 Memory Compiler
-sm_data1_compiler_path ""

# SMData1OptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-sm_data1_optimization_strategy performance

# SMData1HandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-sm_data1_hand_picked_instance ""

# SLCDataCompilerPath --- Path to the SLC Data Memory Compiler
-slc_data_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# SLCDataOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-slc_data_optimization_strategy performance

# SLCDataHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-slc_data_hand_picked_instance ""

# SLCTagCompilerPath --- Path to the SLC Tag Memory Compiler
-slc_tag_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# SLCTagOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-slc_tag_optimization_strategy performance

# SLCTagHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-slc_tag_hand_picked_instance ""

# SLCStatusCompilerPath --- Path to the SLC Status Memory Compiler
-slc_status_compiler_path /slowfs/de02dwt3p010/fsa/complib_release_cot/ts28nmh41p11sassl01ms+

# SLCStatusOptimizationStrategy --- area : smallest memory instances, performance : fastest instances, , hand_picked : Via the associated "hand_picked_instance" option, an existing pre-generated SEIF instance from the specified memory compiler can be specified  e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-slc_status_optimization_strategy performance

# SLCStatusHandPicked --- pre-existing instance name (see build/reports/*.tsv from a previous iteration) e.g. mem_ts28nph41p11sad2l02msa02_2048x16_cm8_bk1_cdfalse_bwe1_bno_rno
-slc_status_hand_picked_instance ""

# memLibPath --- Path to where Memories should be generated
-mem_lib_path /slowfs/de02dwt2p038/Gen2_libs/ip_mem/arc_hs48x4

# PruneMemorySet --- Prune all but fasted and smallest instances
-prune_memory_set true

# MemoryBoost --- Memory Boost by enabling Center Decoder
-memory_boost true

# ITenabled --- Enable Integrated Test option for Synopsys memory compilers
-it_enable false

# PowerGateEnabled --- Enable pg_enable option for Synopsys memory compilers where supported. Only enable when power domains are configured in HS or EM
-pg_enable false

# BtbSlicing --- Specifies amount of slicing of btb ram for performance enhancement (none => 1 instance of 64-bit or 72-bit,  medium => 2 instances of 32-bit or 3 instances of 24-bit, high => 8 or 9 instances of 8-bit
-btb_slicing none

# MwicNumSlices --- Amount of data width slicing to be applied to instruction cache data ram for faster performance
-mwic_num_slices 1

# DcDataNumSlices --- Amount of data width slicing to be applied to data cache data ram for faster performance
-dcdata_num_slices 1

# PatchMemModel --- Default initial content is all zero. Enable this option to have random content intsead. For DCCM with ECC/Parity, use zero initialized memories on post-SEIF RTL simulations of CCT's
-patch_mem_model true

# GenerateBackendViews --- Generate backend views for Synopsys memory compilers
-generate_backend_views true

# LSPinTieoff --- Tie off LS pins of memories to 1'b0 in case of timing critical setup of de-asserting edge of ls signal from core to memory clock pins. Option applies to all memories
-ls_pin_tieoff true

# BackCompat --- Retain the unused rst_a pin on clkgate modules for  backwards compatability with older RTL
-back_compat false


######## Synopsys RM Physical Flow --- com.synopsys.PhysicalFlow_RM.1_0 ########

# Create Synopsys RM Physical Flow
-create com.synopsys.PhysicalFlow_RM.1_0 "System.Synopsys RM Physical Flow"

# SynopsysPhysicalRM --- Add the Synopsys Physical Full Design Flow component
-synopsys_physical_rm true

# UsefulSkew --- Allow the clock paths to macros to be deliberately skewed in order to redistribute available slack on reg2mem and mem2reg path
-useful_skew false

# EnhancedUsefulSkew --- Skew values are calculated via special script that takes acount of multi-cycle path groups
-enhanced_useful_skew false

# ScanChainsReorder --- Instruct the design flow to automatically reorder the scan chain structures.
-scan_reorder false

# userFloorplanPath --- Pathname of user floorplan
-userfloorplan_path ""

# toplevelpinLocationConstraintsFile --- Pathname+filename of the physical pin location constraints file for top-level design
-toplevel_pin_location_constraints_file ""

# MetalFill --- Metal fill step
# NONE
# ICC
# ICV
-metal_fill NONE

# CreateGDS --- Enable GDS streamout
-create_gds false

# AdvancedNode --- Enable Advanced Node routing optimizations
-advanced_node false

# TwoPassFlow --- Two-pass Flow
-two_pass_flow false

# OCVMargin --- OCV Margin (as percentage ratio, default 10%)
-ocv_margin 0.1

# SaveDiskSpace --- Save Disk Space by not writing out certain large files (SDF, DEF, SPBF. Only use if gatelevel simulation  is not being used
-save_disk_space false


######## Synopsys XG Formal Verification Flow --- com.synopsys.FormalVerification_XG.1_0 ########

# Create Synopsys XG Formal Verification Flow
-create com.synopsys.FormalVerification_XG.1_0 "System.Synopsys XG Formal Verification Flow"

# SynopsysFormal --- Use this option to generate the scripts necessary to run formal verification in Formality
-synopsys_xg_formal true

# IntelMCCSpecific --- When true allows some Intel-MCC specific changes to scripts to be built
-intel_mcc_specific false


######## Synopsys Power Analysis --- com.synopsys.PowerAnalysis.1_0 ########

# Create Synopsys Power Analysis
-create com.synopsys.PowerAnalysis.1_0 "System.Synopsys Power Analysis"

# DcPowerAnalysis --- Command line option to enable power analysis in DC
-synopsys_power_analysis true


######## Synopsys Gate Level Simulation --- com.synopsys.GateLevelSimulation.1_0 ########

# Create Synopsys Gate Level Simulation
-create com.synopsys.GateLevelSimulation.1_0 "System.Synopsys Gate Level Simulation"

# VCSGateLevelSimulation --- Specify the use of VCS for gate level simulation
-vcs_gate_level_simulation true


######## Tool Configuration --- cgen.1_0 ########

# Create Tool Configuration
-create cgen.1_0 "System.Tool Configuration"

# mwdt_version --- Selects the MetaWare version to be used with the TCF file.
# Change from the default to an older or newer toolset version if you want the TCF file to be used with an older or newer version of the MetaWare tools.
-mwdt_version O-2018.06

# code_base_addr --- 
# The base address to assign to the executable code segment in the linker command file when there is no ICCM in the build.  This value is ignored when there is an ICCM.
# 
-code_base_addr 0x0

# data_base_addr --- 
# The base address to assign to the data segment in the linker command file when the data is not being mapped to a DCCM.  This value is ignored when the data segment is mapped to a DCCM, as in that case the base address of the DCCM memory is used.
# 
# A value of 0xffffffff means that the data segment will not be mapped to any specific address.
# 
-data_base_addr 0xffff_ffff

# underscores_in_numbers --- Use underscores in hex numbers to improve readability.
-underscores_in_numbers false

# tcf_rebrand --- Alternate branding of TCF (not used)
-rebrand false


]]></string>
  </configuration>
  <configuration name="assembler_defines" filename="core_config.s">
    <string><![CDATA[
.ifndef __core_config_s
	.define __core_config_s, 1
	.define _TOOL_CONFIG_VER, 10071
	.define	core_config_cir_identity,0x00000054
	.define	core_config_cir_identity_chipid,0
	.define	core_config_cir_identity_arcnum,0
	.define	core_config_cir_identity_arcver,84
	.define	core_config_cir_identity_family,5
	.define	core_config_cir_identity_corever,4
	.define	core_config_cir_aux_volatile,0xf0000002
	.define	core_config_cir_aux_volatile_base_region,15
	.define	core_config_cir_aux_volatile_limit_region,0
	.define	core_config_cir_aux_volatile_s,1
	.define	core_config_cir_aux_volatile_d,0
	.define	core_config_bcr_bcr_ver,0x00000002
	.define	core_config_bcr_bcr_ver_version,2
	.define	core_config_bcr_vecbase_ac_build,0x00000010
	.define	core_config_bcr_vecbase_ac_build_version,4
	.define	core_config_bcr_vecbase_ac_build_vector_config,0
	.define	core_config_bcr_vecbase_ac_build_addr,0
	.define	core_config_bcr_mpu_build,0x00000803
	.define	core_config_bcr_mpu_build_i,0
	.define	core_config_bcr_mpu_build_s,0
	.define	core_config_bcr_mpu_build_regions,8
	.define	core_config_bcr_mpu_build_version,3
	.define	core_config_bcr_rf_build,0x0000c902
	.define	core_config_bcr_rf_build_version,2
	.define	core_config_bcr_rf_build_p,1
	.define	core_config_bcr_rf_build_e,0
	.define	core_config_bcr_rf_build_r,0
	.define	core_config_bcr_rf_build_b,1
	.define	core_config_bcr_rf_build_d,3
	.define	core_config_bcr_mmu_build,0x05e21a4a
	.define	core_config_bcr_mmu_build_version,5
	.define	core_config_bcr_mmu_build_sl,1
	.define	core_config_bcr_mmu_build_psz1,12
	.define	core_config_bcr_mmu_build_psz0,4
	.define	core_config_bcr_mmu_build_dl,0
	.define	core_config_bcr_mmu_build_ct,0
	.define	core_config_bcr_mmu_build_pae,1
	.define	core_config_bcr_mmu_build_ja,2
	.define	core_config_bcr_mmu_build_je,2
	.define	core_config_bcr_mmu_build_jes,1
	.define	core_config_bcr_mmu_build_itlb,1
	.define	core_config_bcr_mmu_build_dtlb,2
	.define	core_config_bcr_d_cache_build,0x10227105
	.define	core_config_bcr_d_cache_build_version,5
	.define	core_config_bcr_d_cache_build_assoc,1
	.define	core_config_bcr_d_cache_build_capacity,7
	.define	core_config_bcr_d_cache_build_bsize,2
	.define	core_config_bcr_d_cache_build_fl,2
	.define	core_config_bcr_d_cache_build_ioc,0
	.define	core_config_bcr_d_cache_build_cp,0
	.define	core_config_bcr_d_cache_build_u,0
	.define	core_config_bcr_d_cache_build_cycles,2
	.define	core_config_bcr_timer_build,0x00010704
	.define	core_config_bcr_timer_build_sp1,0
	.define	core_config_bcr_timer_build_sp0,0
	.define	core_config_bcr_timer_build_p1,0
	.define	core_config_bcr_timer_build_p0,1
	.define	core_config_bcr_timer_build_st1,0
	.define	core_config_bcr_timer_build_st0,0
	.define	core_config_bcr_timer_build_rtc,1
	.define	core_config_bcr_timer_build_rtsc_ver,1
	.define	core_config_bcr_timer_build_rtsc,0
	.define	core_config_bcr_timer_build_t0,1
	.define	core_config_bcr_timer_build_t1,1
	.define	core_config_bcr_timer_build_version,4
	.define	core_config_bcr_ap_build,0x00000205
	.define	core_config_bcr_ap_build_version,5
	.define	core_config_bcr_ap_build_type,2
	.define	core_config_bcr_i_cache_build,0x00237204
	.define	core_config_bcr_i_cache_build_assoc,2
	.define	core_config_bcr_i_cache_build_version,4
	.define	core_config_bcr_i_cache_build_capacity,7
	.define	core_config_bcr_i_cache_build_bsize,3
	.define	core_config_bcr_i_cache_build_fl,2
	.define	core_config_bcr_i_cache_build_d,0
	.define	core_config_bcr_dsp_build,0x00007622
	.define	core_config_bcr_dsp_build_wide,1
	.define	core_config_bcr_dsp_build_itu_pa,1
	.define	core_config_bcr_dsp_build_acc_shift,2
	.define	core_config_bcr_dsp_build_comp,1
	.define	core_config_bcr_dsp_build_divsqrt,2
	.define	core_config_bcr_dsp_build_version,34
	.define	core_config_bcr_multiply_build,0x00023206
	.define	core_config_bcr_multiply_build_version16x16,2
	.define	core_config_bcr_multiply_build_dsp,3
	.define	core_config_bcr_multiply_build_cyc,0
	.define	core_config_bcr_multiply_build_type,2
	.define	core_config_bcr_multiply_build_version32x32,6
	.define	core_config_bcr_swap_build,0x00000003
	.define	core_config_bcr_swap_build_version,3
	.define	core_config_bcr_norm_build,0x00000003
	.define	core_config_bcr_norm_build_version,3
	.define	core_config_bcr_minmax_build,0x00000002
	.define	core_config_bcr_minmax_build_version,2
	.define	core_config_bcr_barrel_build,0x00000303
	.define	core_config_bcr_barrel_build_version,3
	.define	core_config_bcr_barrel_build_shift_option,3
	.define	core_config_bcr_bpu_build,0x03e55b05
	.define	core_config_bcr_bpu_build_version,5
	.define	core_config_bcr_bpu_build_bce,3
	.define	core_config_bcr_bpu_build_pte,3
	.define	core_config_bcr_bpu_build_rse,1
	.define	core_config_bcr_bpu_build_ft,1
	.define	core_config_bcr_bpu_build_ts,18
	.define	core_config_bcr_bpu_build_tqe,3
	.define	core_config_bcr_bpu_build_fbe,3
	.define	core_config_bcr_isa_config,0x23e47402
	.define	core_config_bcr_isa_config_res1,0
	.define	core_config_bcr_isa_config_d,2
	.define	core_config_bcr_isa_config_res2,0
	.define	core_config_bcr_isa_config_f,0
	.define	core_config_bcr_isa_config_c,3
	.define	core_config_bcr_isa_config_l,1
	.define	core_config_bcr_isa_config_n,1
	.define	core_config_bcr_isa_config_a,1
	.define	core_config_bcr_isa_config_b,0
	.define	core_config_bcr_isa_config_addr_size,4
	.define	core_config_bcr_isa_config_lpc_size,7
	.define	core_config_bcr_isa_config_pc_size,4
	.define	core_config_bcr_isa_config_version,2
	.define	core_config_bcr_stack_region_build,0x00000002
	.define	core_config_bcr_fpu_build,0x000f0f01
	.define	core_config_bcr_fpu_build_da,0
	.define	core_config_bcr_fpu_build_dd,1
	.define	core_config_bcr_fpu_build_dc,1
	.define	core_config_bcr_fpu_build_df,1
	.define	core_config_bcr_fpu_build_dp,1
	.define	core_config_bcr_fpu_build_fd_v1,0
	.define	core_config_bcr_fpu_build_pi,0
	.define	core_config_bcr_fpu_build_fd,0
	.define	core_config_bcr_fpu_build_fm,0
	.define	core_config_bcr_fpu_build_sd,1
	.define	core_config_bcr_fpu_build_sc,1
	.define	core_config_bcr_fpu_build_sf,1
	.define	core_config_bcr_fpu_build_sp,1
	.define	core_config_bcr_fpu_build_version,1
	.define	core_config_bcr_agu_build,0x00042403
	.define	core_config_bcr_agu_build_accordian,0
	.define	core_config_bcr_agu_build_wb_size,0
	.define	core_config_bcr_agu_build_num_modifier,4
	.define	core_config_bcr_agu_build_num_offset,2
	.define	core_config_bcr_agu_build_num_addr,4
	.define	core_config_bcr_agu_build_version,3
	.define	core_config_bcr_slc_build,0x00000103
	.define	core_config_bcr_slc_build_number,1
	.define	core_config_bcr_slc_build_version,3
	.define	core_config_bcr_cluster_build,0x01080404
	.define	core_config_bcr_cluster_build_sm,0
	.define	core_config_bcr_cluster_build_per,0
	.define	core_config_bcr_cluster_build_c,1
	.define	core_config_bcr_cluster_build_num_entries,8
	.define	core_config_bcr_cluster_build_num_cores,4
	.define	core_config_bcr_cluster_build_version,4
	.define	core_config_bcr_connect_system_build,0x02847e02
	.define	core_config_bcr_connect_system_build_pdm,1
	.define	core_config_bcr_connect_system_build_idu,1
	.define	core_config_bcr_connect_system_build_corenum,4
	.define	core_config_bcr_connect_system_build_gfrc,1
	.define	core_config_bcr_connect_system_build_icd,1
	.define	core_config_bcr_connect_system_build_pmu,1
	.define	core_config_bcr_connect_system_build_icm,1
	.define	core_config_bcr_connect_system_build_ics,1
	.define	core_config_bcr_connect_system_build_ici,1
	.define	core_config_bcr_connect_system_build_asi,0
	.define	core_config_bcr_connect_system_build_version,2
	.define	core_config_bcr_connect_system_build_llm,0
	.define	core_config_bcr_connect_system_build_rtc,1
	.define	core_config_bcr_connect_system_build_mcd,1
	.define	core_config_bcr_connect_system_build_mps,1
	.define	core_config_bcr_connect_system_build_bsu,0
	.define	core_config_bcr_connect_sema_build,0x00000101
	.define	core_config_bcr_connect_sema_build_numsemas,1
	.define	core_config_bcr_connect_sema_build_version,1
	.define	core_config_bcr_connect_message_build,0x00000203
	.define	core_config_bcr_connect_message_build_msgecc,0
	.define	core_config_bcr_connect_message_build_mpss,2
	.define	core_config_bcr_connect_message_build_version,3
	.define	core_config_bcr_connect_pmu_build,0x00000003
	.define	core_config_bcr_connect_pmu_build_version,3
	.define	core_config_bcr_connect_pmu_build_dvfs,0
	.define	core_config_bcr_connect_pmu_build_pm,0
	.define	core_config_bcr_connect_idu_build,0x00000402
	.define	core_config_bcr_connect_idu_build_cirqnum,4
	.define	core_config_bcr_connect_idu_build_version,2
	.define	core_config_bcr_connect_gfrc_build,0x00000003
	.define	core_config_bcr_connect_gfrc_build_version,3
	.define	core_config_bcr_connect_ici_build,0x00000002
	.define	core_config_bcr_connect_ici_build_version,2
	.define	core_config_bcr_connect_icd_build,0x00000002
	.define	core_config_bcr_connect_icd_build_version,2
	.define	core_config_bcr_connect_pdm_build,0x00000001
	.define	core_config_bcr_connect_pdm_build_version,1
	.define	core_config_bcr_csm_build,0x0001c302
	.define	core_config_bcr_csm_build_csm_ecc1,0
	.define	core_config_bcr_csm_build_csmsize1,0
	.define	core_config_bcr_csm_build_mpnum,1
	.define	core_config_bcr_csm_build_bcycle,3
	.define	core_config_bcr_csm_build_csm_ecc,0
	.define	core_config_bcr_csm_build_csmsize,3
	.define	core_config_bcr_csm_build_version,2
	.define	core_config_bcr_csm_build_llecc,0
	.define	core_config_bcr_csm_build_llmsize,3
	.define	core_config_bcr_dma_build,0x00256301
	.define	core_config_bcr_dma_build_dw,0
	.define	core_config_bcr_dma_build_bnum,2
	.define	core_config_bcr_dma_build_ntrans,1
	.define	core_config_bcr_dma_build_mlen,1
	.define	core_config_bcr_dma_build_dnum,6
	.define	core_config_bcr_dma_build_cnum,3
	.define	core_config_bcr_dma_build_version,1
	.define	core_config_bcr_fmp_build,0x00000f01
	.define	core_config_bcr_fmp_build_t,1
	.define	core_config_bcr_fmp_build_r,1
	.define	core_config_bcr_fmp_build_s,1
	.define	core_config_bcr_fmp_build_d,1
	.define	core_config_bcr_fmp_build_version,1
	.define	core_config_bcr_lpb_build,0x00000801
	.define	core_config_bcr_lpb_build_lpb_num,8
	.define	core_config_bcr_lpb_build_version,1
	.define	core_config_bcr_rtt_build,0x00000304
	.define	core_config_bcr_rtt_build_prod_src_num,0
	.define	core_config_bcr_rtt_build_fl,1
	.define	core_config_bcr_rtt_build_pi,1
	.define	core_config_bcr_rtt_build_version,4
	.define	core_config_bcr_irq_build,0x11464901
	.define	core_config_bcr_irq_build_raz,0
	.define	core_config_bcr_irq_build_nmi,0
	.define	core_config_bcr_irq_build_f,1
	.define	core_config_bcr_irq_build_p,1
	.define	core_config_bcr_irq_build_exts,70
	.define	core_config_bcr_irq_build_irqs,73
	.define	core_config_bcr_irq_build_version,1
	.define	core_config_bcr_pct_build,0x00080503
	.define	core_config_bcr_pct_build_version,3
	.define	core_config_bcr_pct_build_s,1
	.define	core_config_bcr_pct_build_i,1
	.define	core_config_bcr_pct_build_c,8
	.define	core_config_bcr_cc_build,0x007b0002
	.define	core_config_bcr_cc_build_version,2
	.define	core_config_bcr_cc_build_cc,123
	.define	core_config_bcr_pdm_dvfs_build,0x00000304
	.define	core_config_bcr_pdm_dvfs_build_dvfs,1
	.define	core_config_bcr_pdm_dvfs_build_pdm,1
	.define	core_config_bcr_pdm_dvfs_build_version,4
	.define	core_config_bcr_isa_profile,0x00011101
	.define	core_config_bcr_isa_profile_g3,1
	.define	core_config_bcr_isa_profile_g2,1
	.define	core_config_bcr_isa_profile_g1,1
	.define	core_config_bcr_isa_profile_version,1
	.define	core_config_bcr_micro_arch_build,0x00040001
	.define	core_config_bcr_micro_arch_build_minor_rev,1
	.define	core_config_bcr_micro_arch_build_major_rev,0
	.define	core_config_bcr_micro_arch_build_product_family,4
	.define	core_config_bcr_micro_arch_build_reserved,0
	.define	core_config_bcr_smart_build,0x00010003
	.define	core_config_bcr_smart_build_version,3
	.define	core_config_bcr_smart_build_stack_size,64
	.define	core_config_cir_cluster_id,0x00000000
	.define	core_config_cir_cluster_id_cluster_num,0
	.define	core_config_cir_slc_aux_cache_config,0x1f441142
	.define	core_config_cir_slc_aux_cache_config_cache_size,2
	.define	core_config_cir_slc_aux_cache_config_lsize,0
	.define	core_config_cir_slc_aux_cache_config_ways,1
	.define	core_config_cir_slc_aux_cache_config_dbank,1
	.define	core_config_cir_slc_aux_cache_config_data_time,2
	.define	core_config_cir_slc_aux_cache_config_tbank,0
	.define	core_config_cir_slc_aux_cache_config_tag_time,1
	.define	core_config_cir_slc_aux_cache_config_pms,1
	.define	core_config_cir_slc_aux_cache_config_pm_num,31
	.define	core_config_cir_slc_aux_cache_config_b,0
	.define	core_config_cir_slc_aux_cache_config_ep,0
	.define	core_config_cir_slc_bcr2,0x00000000
	.define	core_config_cir_slc_bcr2_ecc_size,0
	.define	core_config_cir_slc_bcr2_error_prot,0
	.define	core_config_family,5
	.define	core_config_core_version,4
	.define	core_config_family_name,"arcv2hs"
	.define	core_config_dual_issue,1
	.define	core_config_code_density,1
	.define	core_config_rgf_num_banks,2
	.define	core_config_rgf_banked_regs,32
	.define	core_config_rgf_num_wr_ports,2
	.define	core_config_endian,"little"
	.define	core_config_endian_little,1
	.define	core_config_endian_big,0
	.define	core_config_lpc_size,32
	.define	core_config_pc_size,32
	.define	core_config_addr_size,32
	.define	core_config_atomic,1
	.define	core_config_ll64,1
	.define	core_config_unaligned,1
	.define	core_config_div_rem,"radix4"
	.define	core_config_div_rem_radix4,1
	.define	core_config_swap,1
	.define	core_config_bitscan,1
	.define	core_config_mpy_option,"qmpyh"
	.define	core_config_mpy_option_num,9
	.define	core_config_shift_assist,1
	.define	core_config_barrel_shifter,1
	.define	core_config_dsp,1
	.define	core_config_dsp3,1
	.define	core_config_dsp_complex,1
	.define	core_config_dsp_divsqrt,"radix4"
	.define	core_config_dsp_divsqrt_radix4,1
	.define	core_config_dsp_itu,1
	.define	core_config_dsp_accshift,"full"
	.define	core_config_dsp_accshift_full,1
	.define	core_config_dsp_wide,1
	.define	core_config_agu_small,1
	.define	core_config_fastmath_div,1
	.define	core_config_fastmath_sqrt,1
	.define	core_config_fastmath_sat,1
	.define	core_config_fastmath_trig,1
	.define	core_config_fpud_div,1
	.define	core_config_fpu_mac,1
	.define	core_config_timer0,1
	.define	core_config_timer0_level,1
	.define	core_config_timer0_vector,16
	.define	core_config_timer1,1
	.define	core_config_timer1_level,0
	.define	core_config_timer1_vector,17
	.define	core_config_rtc,1
	.define	core_config_action_points,8
	.define	core_config_ap_feature,1
	.define	core_config_stack_check,1
	.define	core_config_volatile_base,15
	.define	core_config_volatile_limit,0
	.define	core_config_volatile_strict_ordering,1
	.define	core_config_bpu_bc_entries,2048
	.define	core_config_bpu_pt_entries,16384
	.define	core_config_bpu_rs_entries,8
	.define	core_config_bpu_bc_full_tag,1
	.define	core_config_bpu_bc_tag_size,18
	.define	core_config_bpu_tosq_entries,8
	.define	core_config_bpu_fb_entries,4
	.define	core_config_smart_stack_entries,64
	.define	core_config_mpu_present,1
	.define	core_config_mpu,1
	.define	core_config_mpu_regions,8
	.define	core_config_mmuv5_present,1
	.define	core_config_mmuv5,1
	.define	core_config_mmu_pgsz,8192
	.define	core_config_mmu_pgsz_KM,"8K"
	.define	core_config_mmu_ntlb_entries,1024
	.define	core_config_mmu_stlb_entries,16
	.define	core_config_mmu_super_pgsz,2097152
	.define	core_config_mmu_super_pgsz_KM,"2M"
	.define	core_config_mmu_pae40,1
	.define	core_config_mmu_sasid,1
	.define	core_config_mmu_dtlb_entries,8
	.define	core_config_mmu_itlb_entries,4
	.define	core_config_interrupts_present,1
	.define	core_config_interrupts_number,73
	.define	core_config_interrupts_priorities,2
	.define	core_config_interrupts_externals,70
	.define	core_config_interrupts,73
	.define	core_config_interrupt_priorities,2
	.define	core_config_ext_interrupts,70
	.define	core_config_interrupts_firq,1
	.define	core_config_interrupts_base,0x0
	.define	core_config_dcache_present,1
	.define	core_config_dcache_size,65536
	.define	core_config_dcache_line_size,64
	.define	core_config_dcache_ways,2
	.define	core_config_dcache_feature,2
	.define	core_config_dcache_mem_cycles,2
	.define	core_config_icache_present,1
	.define	core_config_icache_size,65536
	.define	core_config_icache_line_size,64
	.define	core_config_icache_ways,4
	.define	core_config_icache_feature,2
	.define	core_config_pct_counters,8
	.define	core_config_pct_interrupt,1
	.define	core_config_connect_ici,2
	.define	core_config_connect_ics,1
	.define	core_config_connect_ics_num_semas,16
	.define	core_config_connect_icm,3
	.define	core_config_connect_icm_sram_size,512
	.define	core_config_connect_icm_sram_prot,"none"
	.define	core_config_connect_pmu,1
	.define	core_config_connect_icd,2
	.define	core_config_connect_gfrc,3
	.define	core_config_connect_idu,2
	.define	core_config_connect_idu_cirqnum,64
	.define	core_config_connect_pdm,1
	.define	core_config_csm,1
	.define	core_config_csm_size,262144
	.define	core_config_csm_size_KM,"256K"
	.define	core_config_csm_size0,262144
	.define	core_config_csm_size0_KM,"256K"
	.define	core_config_csm_bank_mcycle,4
	.define	core_config_csm_prot,"none"
	.define	core_config_csm_prot0,"none"
	.define	core_config_csm_mpnum,1
	.define	core_config_csm_base,0xb0000000
	.define	core_config_cluster_dma,1
	.define	core_config_cluster_dma_ch_num,8
	.define	core_config_cluster_dma_desc_num,64
	.define	core_config_cluster_dma_max_burst_size,8
	.define	core_config_cluster_dma_max_pend_trans,8
	.define	core_config_cluster_dma_buf_size,64
	.define	core_config_cluster_dma_data_size,64
	.define	core_config_power_domains,1
	.define	core_config_dvfs,1
	.define	core_config_lpb_size,128
	.define	core_config_sl2cache_present,1
	.define	core_config_sl2cache_size,0x80000
	.define	core_config_sl2cache_line_size,128
	.define	core_config_sl2cache_ways,8
	.define	core_config_slc_version,3
	.define	core_config_slc_ecc_data_size,32
	.define	core_config_slc_error_prot,"none"
	.define	core_config_scu,1
	.define	core_config_scu_stb_entries,8
	.define	core_config_scu_coherent_io,1
	.define	core_config_clock_speed,1125
.endif ; __core_config_s

]]></string>
  </configuration>
  <configuration name="C_defines" filename="core_config.h">
    <string><![CDATA[
#ifndef __core_config_h
	#define __core_config_h  1
	#define _TOOL_CONFIG_VER 10071
	#define	core_config_cir_identity	0x00000054
	#define	core_config_cir_identity_chipid	0
	#define	core_config_cir_identity_arcnum	0
	#define	core_config_cir_identity_arcver	84
	#define	core_config_cir_identity_family	5
	#define	core_config_cir_identity_corever	4
	#define	core_config_cir_aux_volatile	0xf0000002
	#define	core_config_cir_aux_volatile_base_region	15
	#define	core_config_cir_aux_volatile_limit_region	0
	#define	core_config_cir_aux_volatile_s	1
	#define	core_config_cir_aux_volatile_d	0
	#define	core_config_bcr_bcr_ver	0x00000002
	#define	core_config_bcr_bcr_ver_version	2
	#define	core_config_bcr_vecbase_ac_build	0x00000010
	#define	core_config_bcr_vecbase_ac_build_version	4
	#define	core_config_bcr_vecbase_ac_build_vector_config	0
	#define	core_config_bcr_vecbase_ac_build_addr	0
	#define	core_config_bcr_mpu_build	0x00000803
	#define	core_config_bcr_mpu_build_i	0
	#define	core_config_bcr_mpu_build_s	0
	#define	core_config_bcr_mpu_build_regions	8
	#define	core_config_bcr_mpu_build_version	3
	#define	core_config_bcr_rf_build	0x0000c902
	#define	core_config_bcr_rf_build_version	2
	#define	core_config_bcr_rf_build_p	1
	#define	core_config_bcr_rf_build_e	0
	#define	core_config_bcr_rf_build_r	0
	#define	core_config_bcr_rf_build_b	1
	#define	core_config_bcr_rf_build_d	3
	#define	core_config_bcr_mmu_build	0x05e21a4a
	#define	core_config_bcr_mmu_build_version	5
	#define	core_config_bcr_mmu_build_sl	1
	#define	core_config_bcr_mmu_build_psz1	12
	#define	core_config_bcr_mmu_build_psz0	4
	#define	core_config_bcr_mmu_build_dl	0
	#define	core_config_bcr_mmu_build_ct	0
	#define	core_config_bcr_mmu_build_pae	1
	#define	core_config_bcr_mmu_build_ja	2
	#define	core_config_bcr_mmu_build_je	2
	#define	core_config_bcr_mmu_build_jes	1
	#define	core_config_bcr_mmu_build_itlb	1
	#define	core_config_bcr_mmu_build_dtlb	2
	#define	core_config_bcr_d_cache_build	0x10227105
	#define	core_config_bcr_d_cache_build_version	5
	#define	core_config_bcr_d_cache_build_assoc	1
	#define	core_config_bcr_d_cache_build_capacity	7
	#define	core_config_bcr_d_cache_build_bsize	2
	#define	core_config_bcr_d_cache_build_fl	2
	#define	core_config_bcr_d_cache_build_ioc	0
	#define	core_config_bcr_d_cache_build_cp	0
	#define	core_config_bcr_d_cache_build_u	0
	#define	core_config_bcr_d_cache_build_cycles	2
	#define	core_config_bcr_timer_build	0x00010704
	#define	core_config_bcr_timer_build_sp1	0
	#define	core_config_bcr_timer_build_sp0	0
	#define	core_config_bcr_timer_build_p1	0
	#define	core_config_bcr_timer_build_p0	1
	#define	core_config_bcr_timer_build_st1	0
	#define	core_config_bcr_timer_build_st0	0
	#define	core_config_bcr_timer_build_rtc	1
	#define	core_config_bcr_timer_build_rtsc_ver	1
	#define	core_config_bcr_timer_build_rtsc	0
	#define	core_config_bcr_timer_build_t0	1
	#define	core_config_bcr_timer_build_t1	1
	#define	core_config_bcr_timer_build_version	4
	#define	core_config_bcr_ap_build	0x00000205
	#define	core_config_bcr_ap_build_version	5
	#define	core_config_bcr_ap_build_type	2
	#define	core_config_bcr_i_cache_build	0x00237204
	#define	core_config_bcr_i_cache_build_assoc	2
	#define	core_config_bcr_i_cache_build_version	4
	#define	core_config_bcr_i_cache_build_capacity	7
	#define	core_config_bcr_i_cache_build_bsize	3
	#define	core_config_bcr_i_cache_build_fl	2
	#define	core_config_bcr_i_cache_build_d	0
	#define	core_config_bcr_dsp_build	0x00007622
	#define	core_config_bcr_dsp_build_wide	1
	#define	core_config_bcr_dsp_build_itu_pa	1
	#define	core_config_bcr_dsp_build_acc_shift	2
	#define	core_config_bcr_dsp_build_comp	1
	#define	core_config_bcr_dsp_build_divsqrt	2
	#define	core_config_bcr_dsp_build_version	34
	#define	core_config_bcr_multiply_build	0x00023206
	#define	core_config_bcr_multiply_build_version16x16	2
	#define	core_config_bcr_multiply_build_dsp	3
	#define	core_config_bcr_multiply_build_cyc	0
	#define	core_config_bcr_multiply_build_type	2
	#define	core_config_bcr_multiply_build_version32x32	6
	#define	core_config_bcr_swap_build	0x00000003
	#define	core_config_bcr_swap_build_version	3
	#define	core_config_bcr_norm_build	0x00000003
	#define	core_config_bcr_norm_build_version	3
	#define	core_config_bcr_minmax_build	0x00000002
	#define	core_config_bcr_minmax_build_version	2
	#define	core_config_bcr_barrel_build	0x00000303
	#define	core_config_bcr_barrel_build_version	3
	#define	core_config_bcr_barrel_build_shift_option	3
	#define	core_config_bcr_bpu_build	0x03e55b05
	#define	core_config_bcr_bpu_build_version	5
	#define	core_config_bcr_bpu_build_bce	3
	#define	core_config_bcr_bpu_build_pte	3
	#define	core_config_bcr_bpu_build_rse	1
	#define	core_config_bcr_bpu_build_ft	1
	#define	core_config_bcr_bpu_build_ts	18
	#define	core_config_bcr_bpu_build_tqe	3
	#define	core_config_bcr_bpu_build_fbe	3
	#define	core_config_bcr_isa_config	0x23e47402
	#define	core_config_bcr_isa_config_res1	0
	#define	core_config_bcr_isa_config_d	2
	#define	core_config_bcr_isa_config_res2	0
	#define	core_config_bcr_isa_config_f	0
	#define	core_config_bcr_isa_config_c	3
	#define	core_config_bcr_isa_config_l	1
	#define	core_config_bcr_isa_config_n	1
	#define	core_config_bcr_isa_config_a	1
	#define	core_config_bcr_isa_config_b	0
	#define	core_config_bcr_isa_config_addr_size	4
	#define	core_config_bcr_isa_config_lpc_size	7
	#define	core_config_bcr_isa_config_pc_size	4
	#define	core_config_bcr_isa_config_version	2
	#define	core_config_bcr_stack_region_build	0x00000002
	#define	core_config_bcr_fpu_build	0x000f0f01
	#define	core_config_bcr_fpu_build_da	0
	#define	core_config_bcr_fpu_build_dd	1
	#define	core_config_bcr_fpu_build_dc	1
	#define	core_config_bcr_fpu_build_df	1
	#define	core_config_bcr_fpu_build_dp	1
	#define	core_config_bcr_fpu_build_fd_v1	0
	#define	core_config_bcr_fpu_build_pi	0
	#define	core_config_bcr_fpu_build_fd	0
	#define	core_config_bcr_fpu_build_fm	0
	#define	core_config_bcr_fpu_build_sd	1
	#define	core_config_bcr_fpu_build_sc	1
	#define	core_config_bcr_fpu_build_sf	1
	#define	core_config_bcr_fpu_build_sp	1
	#define	core_config_bcr_fpu_build_version	1
	#define	core_config_bcr_agu_build	0x00042403
	#define	core_config_bcr_agu_build_accordian	0
	#define	core_config_bcr_agu_build_wb_size	0
	#define	core_config_bcr_agu_build_num_modifier	4
	#define	core_config_bcr_agu_build_num_offset	2
	#define	core_config_bcr_agu_build_num_addr	4
	#define	core_config_bcr_agu_build_version	3
	#define	core_config_bcr_slc_build	0x00000103
	#define	core_config_bcr_slc_build_number	1
	#define	core_config_bcr_slc_build_version	3
	#define	core_config_bcr_cluster_build	0x01080404
	#define	core_config_bcr_cluster_build_sm	0
	#define	core_config_bcr_cluster_build_per	0
	#define	core_config_bcr_cluster_build_c	1
	#define	core_config_bcr_cluster_build_num_entries	8
	#define	core_config_bcr_cluster_build_num_cores	4
	#define	core_config_bcr_cluster_build_version	4
	#define	core_config_bcr_connect_system_build	0x02847e02
	#define	core_config_bcr_connect_system_build_pdm	1
	#define	core_config_bcr_connect_system_build_idu	1
	#define	core_config_bcr_connect_system_build_corenum	4
	#define	core_config_bcr_connect_system_build_gfrc	1
	#define	core_config_bcr_connect_system_build_icd	1
	#define	core_config_bcr_connect_system_build_pmu	1
	#define	core_config_bcr_connect_system_build_icm	1
	#define	core_config_bcr_connect_system_build_ics	1
	#define	core_config_bcr_connect_system_build_ici	1
	#define	core_config_bcr_connect_system_build_asi	0
	#define	core_config_bcr_connect_system_build_version	2
	#define	core_config_bcr_connect_system_build_llm	0
	#define	core_config_bcr_connect_system_build_rtc	1
	#define	core_config_bcr_connect_system_build_mcd	1
	#define	core_config_bcr_connect_system_build_mps	1
	#define	core_config_bcr_connect_system_build_bsu	0
	#define	core_config_bcr_connect_sema_build	0x00000101
	#define	core_config_bcr_connect_sema_build_numsemas	1
	#define	core_config_bcr_connect_sema_build_version	1
	#define	core_config_bcr_connect_message_build	0x00000203
	#define	core_config_bcr_connect_message_build_msgecc	0
	#define	core_config_bcr_connect_message_build_mpss	2
	#define	core_config_bcr_connect_message_build_version	3
	#define	core_config_bcr_connect_pmu_build	0x00000003
	#define	core_config_bcr_connect_pmu_build_version	3
	#define	core_config_bcr_connect_pmu_build_dvfs	0
	#define	core_config_bcr_connect_pmu_build_pm	0
	#define	core_config_bcr_connect_idu_build	0x00000402
	#define	core_config_bcr_connect_idu_build_cirqnum	4
	#define	core_config_bcr_connect_idu_build_version	2
	#define	core_config_bcr_connect_gfrc_build	0x00000003
	#define	core_config_bcr_connect_gfrc_build_version	3
	#define	core_config_bcr_connect_ici_build	0x00000002
	#define	core_config_bcr_connect_ici_build_version	2
	#define	core_config_bcr_connect_icd_build	0x00000002
	#define	core_config_bcr_connect_icd_build_version	2
	#define	core_config_bcr_connect_pdm_build	0x00000001
	#define	core_config_bcr_connect_pdm_build_version	1
	#define	core_config_bcr_csm_build	0x0001c302
	#define	core_config_bcr_csm_build_csm_ecc1	0
	#define	core_config_bcr_csm_build_csmsize1	0
	#define	core_config_bcr_csm_build_mpnum	1
	#define	core_config_bcr_csm_build_bcycle	3
	#define	core_config_bcr_csm_build_csm_ecc	0
	#define	core_config_bcr_csm_build_csmsize	3
	#define	core_config_bcr_csm_build_version	2
	#define	core_config_bcr_csm_build_llecc	0
	#define	core_config_bcr_csm_build_llmsize	3
	#define	core_config_bcr_dma_build	0x00256301
	#define	core_config_bcr_dma_build_dw	0
	#define	core_config_bcr_dma_build_bnum	2
	#define	core_config_bcr_dma_build_ntrans	1
	#define	core_config_bcr_dma_build_mlen	1
	#define	core_config_bcr_dma_build_dnum	6
	#define	core_config_bcr_dma_build_cnum	3
	#define	core_config_bcr_dma_build_version	1
	#define	core_config_bcr_fmp_build	0x00000f01
	#define	core_config_bcr_fmp_build_t	1
	#define	core_config_bcr_fmp_build_r	1
	#define	core_config_bcr_fmp_build_s	1
	#define	core_config_bcr_fmp_build_d	1
	#define	core_config_bcr_fmp_build_version	1
	#define	core_config_bcr_lpb_build	0x00000801
	#define	core_config_bcr_lpb_build_lpb_num	8
	#define	core_config_bcr_lpb_build_version	1
	#define	core_config_bcr_rtt_build	0x00000304
	#define	core_config_bcr_rtt_build_prod_src_num	0
	#define	core_config_bcr_rtt_build_fl	1
	#define	core_config_bcr_rtt_build_pi	1
	#define	core_config_bcr_rtt_build_version	4
	#define	core_config_bcr_irq_build	0x11464901
	#define	core_config_bcr_irq_build_raz	0
	#define	core_config_bcr_irq_build_nmi	0
	#define	core_config_bcr_irq_build_f	1
	#define	core_config_bcr_irq_build_p	1
	#define	core_config_bcr_irq_build_exts	70
	#define	core_config_bcr_irq_build_irqs	73
	#define	core_config_bcr_irq_build_version	1
	#define	core_config_bcr_pct_build	0x00080503
	#define	core_config_bcr_pct_build_version	3
	#define	core_config_bcr_pct_build_s	1
	#define	core_config_bcr_pct_build_i	1
	#define	core_config_bcr_pct_build_c	8
	#define	core_config_bcr_cc_build	0x007b0002
	#define	core_config_bcr_cc_build_version	2
	#define	core_config_bcr_cc_build_cc	123
	#define	core_config_bcr_pdm_dvfs_build	0x00000304
	#define	core_config_bcr_pdm_dvfs_build_dvfs	1
	#define	core_config_bcr_pdm_dvfs_build_pdm	1
	#define	core_config_bcr_pdm_dvfs_build_version	4
	#define	core_config_bcr_isa_profile	0x00011101
	#define	core_config_bcr_isa_profile_g3	1
	#define	core_config_bcr_isa_profile_g2	1
	#define	core_config_bcr_isa_profile_g1	1
	#define	core_config_bcr_isa_profile_version	1
	#define	core_config_bcr_micro_arch_build	0x00040001
	#define	core_config_bcr_micro_arch_build_minor_rev	1
	#define	core_config_bcr_micro_arch_build_major_rev	0
	#define	core_config_bcr_micro_arch_build_product_family	4
	#define	core_config_bcr_micro_arch_build_reserved	0
	#define	core_config_bcr_smart_build	0x00010003
	#define	core_config_bcr_smart_build_version	3
	#define	core_config_bcr_smart_build_stack_size	64
	#define	core_config_cir_cluster_id	0x00000000
	#define	core_config_cir_cluster_id_cluster_num	0
	#define	core_config_cir_slc_aux_cache_config	0x1f441142
	#define	core_config_cir_slc_aux_cache_config_cache_size	2
	#define	core_config_cir_slc_aux_cache_config_lsize	0
	#define	core_config_cir_slc_aux_cache_config_ways	1
	#define	core_config_cir_slc_aux_cache_config_dbank	1
	#define	core_config_cir_slc_aux_cache_config_data_time	2
	#define	core_config_cir_slc_aux_cache_config_tbank	0
	#define	core_config_cir_slc_aux_cache_config_tag_time	1
	#define	core_config_cir_slc_aux_cache_config_pms	1
	#define	core_config_cir_slc_aux_cache_config_pm_num	31
	#define	core_config_cir_slc_aux_cache_config_b	0
	#define	core_config_cir_slc_aux_cache_config_ep	0
	#define	core_config_cir_slc_bcr2	0x00000000
	#define	core_config_cir_slc_bcr2_ecc_size	0
	#define	core_config_cir_slc_bcr2_error_prot	0
	#define	core_config_family	5
	#define	core_config_core_version	4
	#define	core_config_family_name	"arcv2hs"
	#define	core_config_dual_issue	1
	#define	core_config_code_density	1
	#define	core_config_rgf_num_banks	2
	#define	core_config_rgf_banked_regs	32
	#define	core_config_rgf_num_wr_ports	2
	#define	core_config_endian	"little"
	#define	core_config_endian_little	1
	#define	core_config_endian_big	0
	#define	core_config_lpc_size	32
	#define	core_config_pc_size	32
	#define	core_config_addr_size	32
	#define	core_config_atomic	1
	#define	core_config_ll64	1
	#define	core_config_unaligned	1
	#define	core_config_div_rem	"radix4"
	#define	core_config_div_rem_radix4	1
	#define	core_config_swap	1
	#define	core_config_bitscan	1
	#define	core_config_mpy_option	"qmpyh"
	#define	core_config_mpy_option_num	9
	#define	core_config_shift_assist	1
	#define	core_config_barrel_shifter	1
	#define	core_config_dsp	1
	#define	core_config_dsp3	1
	#define	core_config_dsp_complex	1
	#define	core_config_dsp_divsqrt	"radix4"
	#define	core_config_dsp_divsqrt_radix4	1
	#define	core_config_dsp_itu	1
	#define	core_config_dsp_accshift	"full"
	#define	core_config_dsp_accshift_full	1
	#define	core_config_dsp_wide	1
	#define	core_config_agu_small	1
	#define	core_config_fastmath_div	1
	#define	core_config_fastmath_sqrt	1
	#define	core_config_fastmath_sat	1
	#define	core_config_fastmath_trig	1
	#define	core_config_fpud_div	1
	#define	core_config_fpu_mac	1
	#define	core_config_timer0	1
	#define	core_config_timer0_level	1
	#define	core_config_timer0_vector	16
	#define	core_config_timer1	1
	#define	core_config_timer1_level	0
	#define	core_config_timer1_vector	17
	#define	core_config_rtc	1
	#define	core_config_action_points	8
	#define	core_config_ap_feature	1
	#define	core_config_stack_check	1
	#define	core_config_volatile_base	15
	#define	core_config_volatile_limit	0
	#define	core_config_volatile_strict_ordering	1
	#define	core_config_bpu_bc_entries	2048
	#define	core_config_bpu_pt_entries	16384
	#define	core_config_bpu_rs_entries	8
	#define	core_config_bpu_bc_full_tag	1
	#define	core_config_bpu_bc_tag_size	18
	#define	core_config_bpu_tosq_entries	8
	#define	core_config_bpu_fb_entries	4
	#define	core_config_smart_stack_entries	64
	#define	core_config_mpu_present	1
	#define	core_config_mpu	1
	#define	core_config_mpu_regions	8
	#define	core_config_mmuv5_present	1
	#define	core_config_mmuv5	1
	#define	core_config_mmu_pgsz	8192
	#define	core_config_mmu_pgsz_KM	"8K"
	#define	core_config_mmu_ntlb_entries	1024
	#define	core_config_mmu_stlb_entries	16
	#define	core_config_mmu_super_pgsz	2097152
	#define	core_config_mmu_super_pgsz_KM	"2M"
	#define	core_config_mmu_pae40	1
	#define	core_config_mmu_sasid	1
	#define	core_config_mmu_dtlb_entries	8
	#define	core_config_mmu_itlb_entries	4
	#define	core_config_interrupts_present	1
	#define	core_config_interrupts_number	73
	#define	core_config_interrupts_priorities	2
	#define	core_config_interrupts_externals	70
	#define	core_config_interrupts	73
	#define	core_config_interrupt_priorities	2
	#define	core_config_ext_interrupts	70
	#define	core_config_interrupts_firq	1
	#define	core_config_interrupts_base	0x0
	#define	core_config_dcache_present	1
	#define	core_config_dcache_size	65536
	#define	core_config_dcache_line_size	64
	#define	core_config_dcache_ways	2
	#define	core_config_dcache_feature	2
	#define	core_config_dcache_mem_cycles	2
	#define	core_config_icache_present	1
	#define	core_config_icache_size	65536
	#define	core_config_icache_line_size	64
	#define	core_config_icache_ways	4
	#define	core_config_icache_feature	2
	#define	core_config_pct_counters	8
	#define	core_config_pct_interrupt	1
	#define	core_config_connect_ici	2
	#define	core_config_connect_ics	1
	#define	core_config_connect_ics_num_semas	16
	#define	core_config_connect_icm	3
	#define	core_config_connect_icm_sram_size	512
	#define	core_config_connect_icm_sram_prot	"none"
	#define	core_config_connect_pmu	1
	#define	core_config_connect_icd	2
	#define	core_config_connect_gfrc	3
	#define	core_config_connect_idu	2
	#define	core_config_connect_idu_cirqnum	64
	#define	core_config_connect_pdm	1
	#define	core_config_csm	1
	#define	core_config_csm_size	262144
	#define	core_config_csm_size_KM	"256K"
	#define	core_config_csm_size0	262144
	#define	core_config_csm_size0_KM	"256K"
	#define	core_config_csm_bank_mcycle	4
	#define	core_config_csm_prot	"none"
	#define	core_config_csm_prot0	"none"
	#define	core_config_csm_mpnum	1
	#define	core_config_csm_base	0xb0000000
	#define	core_config_cluster_dma	1
	#define	core_config_cluster_dma_ch_num	8
	#define	core_config_cluster_dma_desc_num	64
	#define	core_config_cluster_dma_max_burst_size	8
	#define	core_config_cluster_dma_max_pend_trans	8
	#define	core_config_cluster_dma_buf_size	64
	#define	core_config_cluster_dma_data_size	64
	#define	core_config_power_domains	1
	#define	core_config_dvfs	1
	#define	core_config_lpb_size	128
	#define	core_config_sl2cache_present	1
	#define	core_config_sl2cache_size	0x80000
	#define	core_config_sl2cache_line_size	128
	#define	core_config_sl2cache_ways	8
	#define	core_config_slc_version	3
	#define	core_config_slc_ecc_data_size	32
	#define	core_config_slc_error_prot	"none"
	#define	core_config_scu	1
	#define	core_config_scu_stb_entries	8
	#define	core_config_scu_coherent_io	1
	#define	core_config_clock_speed	1125
#endif /* __core_config_h */

]]></string>
  </configuration>
  <configuration name="core" filename="core.props">
    <string><![CDATA[
	core_config.cir.identity=0x00000054
	core_config.cir.identity.chipid=0
	core_config.cir.identity.arcnum=0
	core_config.cir.identity.arcver=84
	core_config.cir.identity.family=5
	core_config.cir.identity.corever=4
	core_config.cir.aux_volatile=0xf0000002
	core_config.cir.aux_volatile.base_region=15
	core_config.cir.aux_volatile.limit_region=0
	core_config.cir.aux_volatile.s=1
	core_config.cir.aux_volatile.d=0
	core_config.bcr.bcr_ver=0x00000002
	core_config.bcr.bcr_ver.version=2
	core_config.bcr.vecbase_ac_build=0x00000010
	core_config.bcr.vecbase_ac_build.version=4
	core_config.bcr.vecbase_ac_build.vector_config=0
	core_config.bcr.vecbase_ac_build.addr=0
	core_config.bcr.mpu_build=0x00000803
	core_config.bcr.mpu_build.i=0
	core_config.bcr.mpu_build.s=0
	core_config.bcr.mpu_build.regions=8
	core_config.bcr.mpu_build.version=3
	core_config.bcr.rf_build=0x0000c902
	core_config.bcr.rf_build.version=2
	core_config.bcr.rf_build.p=1
	core_config.bcr.rf_build.e=0
	core_config.bcr.rf_build.r=0
	core_config.bcr.rf_build.b=1
	core_config.bcr.rf_build.d=3
	core_config.bcr.mmu_build=0x05e21a4a
	core_config.bcr.mmu_build.version=5
	core_config.bcr.mmu_build.sl=1
	core_config.bcr.mmu_build.psz1=12
	core_config.bcr.mmu_build.psz0=4
	core_config.bcr.mmu_build.dl=0
	core_config.bcr.mmu_build.ct=0
	core_config.bcr.mmu_build.pae=1
	core_config.bcr.mmu_build.ja=2
	core_config.bcr.mmu_build.je=2
	core_config.bcr.mmu_build.jes=1
	core_config.bcr.mmu_build.itlb=1
	core_config.bcr.mmu_build.dtlb=2
	core_config.bcr.d_cache_build=0x10227105
	core_config.bcr.d_cache_build.version=5
	core_config.bcr.d_cache_build.assoc=1
	core_config.bcr.d_cache_build.capacity=7
	core_config.bcr.d_cache_build.bsize=2
	core_config.bcr.d_cache_build.fl=2
	core_config.bcr.d_cache_build.ioc=0
	core_config.bcr.d_cache_build.cp=0
	core_config.bcr.d_cache_build.u=0
	core_config.bcr.d_cache_build.cycles=2
	core_config.bcr.timer_build=0x00010704
	core_config.bcr.timer_build.sp1=0
	core_config.bcr.timer_build.sp0=0
	core_config.bcr.timer_build.p1=0
	core_config.bcr.timer_build.p0=1
	core_config.bcr.timer_build.st1=0
	core_config.bcr.timer_build.st0=0
	core_config.bcr.timer_build.rtc=1
	core_config.bcr.timer_build.rtsc_ver=1
	core_config.bcr.timer_build.rtsc=0
	core_config.bcr.timer_build.t0=1
	core_config.bcr.timer_build.t1=1
	core_config.bcr.timer_build.version=4
	core_config.bcr.ap_build=0x00000205
	core_config.bcr.ap_build.version=5
	core_config.bcr.ap_build.type=2
	core_config.bcr.i_cache_build=0x00237204
	core_config.bcr.i_cache_build.assoc=2
	core_config.bcr.i_cache_build.version=4
	core_config.bcr.i_cache_build.capacity=7
	core_config.bcr.i_cache_build.bsize=3
	core_config.bcr.i_cache_build.fl=2
	core_config.bcr.i_cache_build.d=0
	core_config.bcr.dsp_build=0x00007622
	core_config.bcr.dsp_build.wide=1
	core_config.bcr.dsp_build.itu_pa=1
	core_config.bcr.dsp_build.acc_shift=2
	core_config.bcr.dsp_build.comp=1
	core_config.bcr.dsp_build.divsqrt=2
	core_config.bcr.dsp_build.version=34
	core_config.bcr.multiply_build=0x00023206
	core_config.bcr.multiply_build.version16x16=2
	core_config.bcr.multiply_build.dsp=3
	core_config.bcr.multiply_build.cyc=0
	core_config.bcr.multiply_build.type=2
	core_config.bcr.multiply_build.version32x32=6
	core_config.bcr.swap_build=0x00000003
	core_config.bcr.swap_build.version=3
	core_config.bcr.norm_build=0x00000003
	core_config.bcr.norm_build.version=3
	core_config.bcr.minmax_build=0x00000002
	core_config.bcr.minmax_build.version=2
	core_config.bcr.barrel_build=0x00000303
	core_config.bcr.barrel_build.version=3
	core_config.bcr.barrel_build.shift_option=3
	core_config.bcr.bpu_build=0x03e55b05
	core_config.bcr.bpu_build.version=5
	core_config.bcr.bpu_build.bce=3
	core_config.bcr.bpu_build.pte=3
	core_config.bcr.bpu_build.rse=1
	core_config.bcr.bpu_build.ft=1
	core_config.bcr.bpu_build.ts=18
	core_config.bcr.bpu_build.tqe=3
	core_config.bcr.bpu_build.fbe=3
	core_config.bcr.isa_config=0x23e47402
	core_config.bcr.isa_config.res1=0
	core_config.bcr.isa_config.d=2
	core_config.bcr.isa_config.res2=0
	core_config.bcr.isa_config.f=0
	core_config.bcr.isa_config.c=3
	core_config.bcr.isa_config.l=1
	core_config.bcr.isa_config.n=1
	core_config.bcr.isa_config.a=1
	core_config.bcr.isa_config.b=0
	core_config.bcr.isa_config.addr_size=4
	core_config.bcr.isa_config.lpc_size=7
	core_config.bcr.isa_config.pc_size=4
	core_config.bcr.isa_config.version=2
	core_config.bcr.stack_region_build=0x00000002
	core_config.bcr.fpu_build=0x000f0f01
	core_config.bcr.fpu_build.da=0
	core_config.bcr.fpu_build.dd=1
	core_config.bcr.fpu_build.dc=1
	core_config.bcr.fpu_build.df=1
	core_config.bcr.fpu_build.dp=1
	core_config.bcr.fpu_build.fd_v1=0
	core_config.bcr.fpu_build.pi=0
	core_config.bcr.fpu_build.fd=0
	core_config.bcr.fpu_build.fm=0
	core_config.bcr.fpu_build.sd=1
	core_config.bcr.fpu_build.sc=1
	core_config.bcr.fpu_build.sf=1
	core_config.bcr.fpu_build.sp=1
	core_config.bcr.fpu_build.version=1
	core_config.bcr.agu_build=0x00042403
	core_config.bcr.agu_build.accordian=0
	core_config.bcr.agu_build.wb_size=0
	core_config.bcr.agu_build.num_modifier=4
	core_config.bcr.agu_build.num_offset=2
	core_config.bcr.agu_build.num_addr=4
	core_config.bcr.agu_build.version=3
	core_config.bcr.slc_build=0x00000103
	core_config.bcr.slc_build.number=1
	core_config.bcr.slc_build.version=3
	core_config.bcr.cluster_build=0x01080404
	core_config.bcr.cluster_build.sm=0
	core_config.bcr.cluster_build.per=0
	core_config.bcr.cluster_build.c=1
	core_config.bcr.cluster_build.num_entries=8
	core_config.bcr.cluster_build.num_cores=4
	core_config.bcr.cluster_build.version=4
	core_config.bcr.connect_system_build=0x02847e02
	core_config.bcr.connect_system_build.pdm=1
	core_config.bcr.connect_system_build.idu=1
	core_config.bcr.connect_system_build.corenum=4
	core_config.bcr.connect_system_build.gfrc=1
	core_config.bcr.connect_system_build.icd=1
	core_config.bcr.connect_system_build.pmu=1
	core_config.bcr.connect_system_build.icm=1
	core_config.bcr.connect_system_build.ics=1
	core_config.bcr.connect_system_build.ici=1
	core_config.bcr.connect_system_build.asi=0
	core_config.bcr.connect_system_build.version=2
	core_config.bcr.connect_system_build.llm=0
	core_config.bcr.connect_system_build.rtc=1
	core_config.bcr.connect_system_build.mcd=1
	core_config.bcr.connect_system_build.mps=1
	core_config.bcr.connect_system_build.bsu=0
	core_config.bcr.connect_sema_build=0x00000101
	core_config.bcr.connect_sema_build.numsemas=1
	core_config.bcr.connect_sema_build.version=1
	core_config.bcr.connect_message_build=0x00000203
	core_config.bcr.connect_message_build.msgecc=0
	core_config.bcr.connect_message_build.mpss=2
	core_config.bcr.connect_message_build.version=3
	core_config.bcr.connect_pmu_build=0x00000003
	core_config.bcr.connect_pmu_build.version=3
	core_config.bcr.connect_pmu_build.dvfs=0
	core_config.bcr.connect_pmu_build.pm=0
	core_config.bcr.connect_idu_build=0x00000402
	core_config.bcr.connect_idu_build.cirqnum=4
	core_config.bcr.connect_idu_build.version=2
	core_config.bcr.connect_gfrc_build=0x00000003
	core_config.bcr.connect_gfrc_build.version=3
	core_config.bcr.connect_ici_build=0x00000002
	core_config.bcr.connect_ici_build.version=2
	core_config.bcr.connect_icd_build=0x00000002
	core_config.bcr.connect_icd_build.version=2
	core_config.bcr.connect_pdm_build=0x00000001
	core_config.bcr.connect_pdm_build.version=1
	core_config.bcr.csm_build=0x0001c302
	core_config.bcr.csm_build.csm_ecc1=0
	core_config.bcr.csm_build.csmsize1=0
	core_config.bcr.csm_build.mpnum=1
	core_config.bcr.csm_build.bcycle=3
	core_config.bcr.csm_build.csm_ecc=0
	core_config.bcr.csm_build.csmsize=3
	core_config.bcr.csm_build.version=2
	core_config.bcr.csm_build.llecc=0
	core_config.bcr.csm_build.llmsize=3
	core_config.bcr.dma_build=0x00256301
	core_config.bcr.dma_build.dw=0
	core_config.bcr.dma_build.bnum=2
	core_config.bcr.dma_build.ntrans=1
	core_config.bcr.dma_build.mlen=1
	core_config.bcr.dma_build.dnum=6
	core_config.bcr.dma_build.cnum=3
	core_config.bcr.dma_build.version=1
	core_config.bcr.fmp_build=0x00000f01
	core_config.bcr.fmp_build.t=1
	core_config.bcr.fmp_build.r=1
	core_config.bcr.fmp_build.s=1
	core_config.bcr.fmp_build.d=1
	core_config.bcr.fmp_build.version=1
	core_config.bcr.lpb_build=0x00000801
	core_config.bcr.lpb_build.lpb_num=8
	core_config.bcr.lpb_build.version=1
	core_config.bcr.rtt_build=0x00000304
	core_config.bcr.rtt_build.prod_src_num=0
	core_config.bcr.rtt_build.fl=1
	core_config.bcr.rtt_build.pi=1
	core_config.bcr.rtt_build.version=4
	core_config.bcr.irq_build=0x11464901
	core_config.bcr.irq_build.raz=0
	core_config.bcr.irq_build.nmi=0
	core_config.bcr.irq_build.f=1
	core_config.bcr.irq_build.p=1
	core_config.bcr.irq_build.exts=70
	core_config.bcr.irq_build.irqs=73
	core_config.bcr.irq_build.version=1
	core_config.bcr.pct_build=0x00080503
	core_config.bcr.pct_build.version=3
	core_config.bcr.pct_build.s=1
	core_config.bcr.pct_build.i=1
	core_config.bcr.pct_build.c=8
	core_config.bcr.cc_build=0x007b0002
	core_config.bcr.cc_build.version=2
	core_config.bcr.cc_build.cc=123
	core_config.bcr.pdm_dvfs_build=0x00000304
	core_config.bcr.pdm_dvfs_build.dvfs=1
	core_config.bcr.pdm_dvfs_build.pdm=1
	core_config.bcr.pdm_dvfs_build.version=4
	core_config.bcr.isa_profile=0x00011101
	core_config.bcr.isa_profile.g3=1
	core_config.bcr.isa_profile.g2=1
	core_config.bcr.isa_profile.g1=1
	core_config.bcr.isa_profile.version=1
	core_config.bcr.micro_arch_build=0x00040001
	core_config.bcr.micro_arch_build.minor_rev=1
	core_config.bcr.micro_arch_build.major_rev=0
	core_config.bcr.micro_arch_build.product_family=4
	core_config.bcr.micro_arch_build.reserved=0
	core_config.bcr.smart_build=0x00010003
	core_config.bcr.smart_build.version=3
	core_config.bcr.smart_build.stack_size=64
	core_config.cir.cluster_id=0x00000000
	core_config.cir.cluster_id.cluster_num=0
	core_config.cir.slc_aux_cache_config=0x1f441142
	core_config.cir.slc_aux_cache_config.cache_size=2
	core_config.cir.slc_aux_cache_config.lsize=0
	core_config.cir.slc_aux_cache_config.ways=1
	core_config.cir.slc_aux_cache_config.dbank=1
	core_config.cir.slc_aux_cache_config.data_time=2
	core_config.cir.slc_aux_cache_config.tbank=0
	core_config.cir.slc_aux_cache_config.tag_time=1
	core_config.cir.slc_aux_cache_config.pms=1
	core_config.cir.slc_aux_cache_config.pm_num=31
	core_config.cir.slc_aux_cache_config.b=0
	core_config.cir.slc_aux_cache_config.ep=0
	core_config.cir.slc_bcr2=0x00000000
	core_config.cir.slc_bcr2.ecc_size=0
	core_config.cir.slc_bcr2.error_prot=0
	core_config.family=5
	core_config.core_version=4
	core_config.family_name=arcv2hs
	core_config.dual_issue=1
	core_config.code_density=1
	core_config.rgf_num_banks=2
	core_config.rgf_banked_regs=32
	core_config.rgf_num_wr_ports=2
	core_config.endian=little
	core_config.endian_little=1
	core_config.endian_big=0
	core_config.lpc_size=32
	core_config.pc_size=32
	core_config.addr_size=32
	core_config.atomic=1
	core_config.ll64=1
	core_config.unaligned=1
	core_config.div_rem=radix4
	core_config.div_rem_radix4=1
	core_config.swap=1
	core_config.bitscan=1
	core_config.mpy_option=qmpyh
	core_config.mpy_option_num=9
	core_config.shift_assist=1
	core_config.barrel_shifter=1
	core_config.dsp=1
	core_config.dsp3=1
	core_config.dsp_complex=1
	core_config.dsp_divsqrt=radix4
	core_config.dsp_divsqrt_radix4=1
	core_config.dsp_itu=1
	core_config.dsp_accshift=full
	core_config.dsp_accshift_full=1
	core_config.dsp_wide=1
	core_config.agu_small=1
	core_config.fastmath_div=1
	core_config.fastmath_sqrt=1
	core_config.fastmath_sat=1
	core_config.fastmath_trig=1
	core_config.fpud_div=1
	core_config.fpu_mac=1
	core_config.timer0=1
	core_config.timer0_level=1
	core_config.timer0.vector=16
	core_config.timer1=1
	core_config.timer1_level=0
	core_config.timer1.vector=17
	core_config.rtc=1
	core_config.action_points=8
	core_config.ap_feature=1
	core_config.stack_check=1
	core_config.volatile_base=15
	core_config.volatile_limit=0
	core_config.volatile_strict_ordering=1
	core_config.bpu_bc_entries=2048
	core_config.bpu_pt_entries=16384
	core_config.bpu_rs_entries=8
	core_config.bpu_bc_full_tag=1
	core_config.bpu_bc_tag_size=18
	core_config.bpu_tosq_entries=8
	core_config.bpu_fb_entries=4
	core_config.smart_stack_entries=64
	core_config.mpu.present=1
	core_config.mpu=1
	core_config.mpu.regions=8
	core_config.mmuv5.present=1
	core_config.mmuv5=1
	core_config.mmu_pgsz=8K
	core_config.mmu_ntlb_entries=1024
	core_config.mmu_stlb_entries=16
	core_config.mmu_super_pgsz=2M
	core_config.mmu_pae40=1
	core_config.mmu_sasid=1
	core_config.mmu_dtlb_entries=8
	core_config.mmu_itlb_entries=4
	core_config.interrupts.present=1
	core_config.interrupts.number=73
	core_config.interrupts.priorities=2
	core_config.interrupts.externals=70
	core_config.interrupts=73
	core_config.interrupt_priorities=2
	core_config.ext_interrupts=70
	core_config.interrupts.firq=1
	core_config.interrupts.base=0x0
	core_config.dcache.present=1
	core_config.dcache.size=65536
	core_config.dcache.line_size=64
	core_config.dcache.ways=2
	core_config.dcache_feature=2
	core_config.dcache_mem_cycles=2
	core_config.icache.present=1
	core_config.icache.size=65536
	core_config.icache.line_size=64
	core_config.icache.ways=4
	core_config.icache_feature=2
	core_config.pct_counters=8
	core_config.pct_interrupt=1
	core_config.connect_ici=2
	core_config.connect_ics=1
	core_config.connect_ics_num_semas=16
	core_config.connect_icm=3
	core_config.connect_icm_sram_size=512
	core_config.connect_icm_sram_prot=none
	core_config.connect_pmu=1
	core_config.connect_icd=2
	core_config.connect_gfrc=3
	core_config.connect_idu=2
	core_config.connect_idu_cirqnum=64
	core_config.connect_pdm=1
	core_config.csm=1
	core_config.csm_size=256K
	core_config.csm_size0=256K
	core_config.csm_bank_mcycle=4
	core_config.csm_prot=none
	core_config.csm_prot0=none
	core_config.csm_mpnum=1
	core_config.csm_base=0xb0000000
	core_config.cluster_dma=1
	core_config.cluster_dma_ch_num=8
	core_config.cluster_dma_desc_num=64
	core_config.cluster_dma_max_burst_size=8
	core_config.cluster_dma_max_pend_trans=8
	core_config.cluster_dma_buf_size=64
	core_config.cluster_dma_data_size=64
	core_config.power_domains=1
	core_config.dvfs=1
	core_config.lpb_size=128
	core_config.sl2cache.present=1
	core_config.sl2cache.size=0x80000
	core_config.sl2cache.line_size=128
	core_config.sl2cache.ways=8
	core_config.slc_version=3
	core_config.slc_ecc_data_size=32
	core_config.slc_error_prot=none
	core_config.scu=1
	core_config.scu_stb_entries=8
	core_config.scu_coherent_io=1
	core_config.clock_speed=1125
]]></string>
  </configuration>
  <configuration name="gcc_compiler" filename="gcc.arg">
    <string><![CDATA[
	-mcpu=hs38_linux
	-mlittle-endian
	-matomic
	-mll64
	-mdiv-rem
	-mswap
	-mnorm
	-mmpy-option=9
	-mbarrel-shifter
	-mfpu=fpud_all
	--param l1-cache-size=65536
	--param l1-cache-line-size=64
]]></string>
  </configuration>
  <configuration name="linker_command_file" filename="link_cmd.txt">
    <string><![CDATA[
# SYSTEM memory regions indicate where external memory might be located.
#   The TCF has no specific knowledge of whether SYSTEM regions contain 
#   external memory or not.
# CCMWRAP memory regions indicate unusable portions of the address space
#   due to CCM memory wrapping into upper addresses beyond its size

MEMORY {
    SYSTEM0 : ORIGIN = 0x00000000, LENGTH = 0xb0000000
    CSM     : ORIGIN = 0xb0000000, LENGTH = 0x00040000
#   CCMWRAP0: ORIGIN = 0xb0040000, LENGTH = 0x0ffc0000
#   SYSTEM1 : ORIGIN = 0xc0000000, LENGTH = 0x40000000
    }
SECTIONS {
    GROUP BLOCK(4) : {
        .vectors (TEXT) SIZE(DEFINED _IVTSIZE?_IVTSIZE:636): {}
	.text? : { *('.text$crt*') }
        * (TEXT): {}
    	* (LIT): {}
	} > SYSTEM0

    GROUP BLOCK(4): {
	/* _SDA_BASE_ computed implicitly */
        .sdata?: {}
        .sbss?: {}
        * (DATA): {}
        * (BSS): {}
       .stack ALIGN(4) SIZE(DEFINED _STACKSIZE?_STACKSIZE:65536): {}
       .heap? ALIGN(4) SIZE(DEFINED _HEAPSIZE?_HEAPSIZE:0): {}
	} > SYSTEM0
    GROUP ALIGN(64) BLOCK(4): {
        .csm_data? : {}
        } > CSM
    }

]]></string>
  </configuration>
  <configuration name="gnu_linker_command_file" filename="memory.x">
    <string><![CDATA[
MEMORY {
    SYSTEM0  : ORIGIN = 0x00000000, LENGTH = 0xb0000000
    CSM      : ORIGIN = 0xb0000000, LENGTH = 0x00040000
    CCMWRAP0 : ORIGIN = 0xb0040000, LENGTH = 0x0ffc0000
    SYSTEM1  : ORIGIN = 0xc0000000, LENGTH = 0x40000000
    }
REGION_ALIAS("startup", SYSTEM0)
REGION_ALIAS("text", SYSTEM0)
REGION_ALIAS("data", SYSTEM0)
REGION_ALIAS("sdata", SYSTEM0)
PROVIDE (__stack_top = (0xafffffff & -4 ));
PROVIDE (__end_heap =  (0xafffffff ));
]]></string>
  </configuration>
  <configuration name="apex_header" filename="apexextensions.h">
    <string><![CDATA[

/* **** DO NOT EDIT - this file is generated by ARChitect2 ****
 *
 * Description: Header file declaring the compiler extensions for apex components 
 */

#ifndef _apexextensions_H_
#define _apexextensions_H_

#define APEX_COM_ARC_HARDWARE_FASTMATH_PRESENT	1

// User extension aux register FMP_CTRL
#define AR_FMP_CTRL 0x470
#pragma Aux_register(0x470, name=>"FMP_CTRL")

// User extension aux register FMP_BUILD
#define AR_FMP_BUILD 0xe8
#pragma Aux_register(0xe8, name=>"FMP_BUILD")

// User extension instruction FMP_DIVF
extern int FMP_DIVF(int,int);
#pragma intrinsic(FMP_DIVF,opcode=>7,sub_opcode=>32, effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_DIVF
extern int FMP_DIVF_f(int,int);
#pragma intrinsic(FMP_DIVF_f,opcode=>7,sub_opcode=>32, set_flags => 1, flags => "zncv", effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_DIVF15
extern int FMP_DIVF15(int,int);
#pragma intrinsic(FMP_DIVF15,opcode=>7,sub_opcode=>33, effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_DIVF15
extern int FMP_DIVF15_f(int,int);
#pragma intrinsic(FMP_DIVF15_f,opcode=>7,sub_opcode=>33, set_flags => 1, flags => "zncv", effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_ADDS
extern int FMP_ADDS(int,int);
#pragma intrinsic(FMP_ADDS,opcode=>7,sub_opcode=>34, effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_ADDS
extern int FMP_ADDS_f(int,int);
#pragma intrinsic(FMP_ADDS_f,opcode=>7,sub_opcode=>34, set_flags => 1, flags => "zncv", effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_RECIP
extern int FMP_RECIP(int);
#pragma intrinsic(FMP_RECIP,opcode=>7,sub_opcode=>42, effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_RECIP
extern int FMP_RECIP_f(int);
#pragma intrinsic(FMP_RECIP_f,opcode=>7,sub_opcode=>42, set_flags => 1, flags => "zncv", effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_RECIP15
extern int FMP_RECIP15(int);
#pragma intrinsic(FMP_RECIP15,opcode=>7,sub_opcode=>43, effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_RECIP15
extern int FMP_RECIP15_f(int);
#pragma intrinsic(FMP_RECIP15_f,opcode=>7,sub_opcode=>43, set_flags => 1, flags => "zncv", effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_SQRTF
extern int FMP_SQRTF(int);
#pragma intrinsic(FMP_SQRTF,opcode=>7,sub_opcode=>32, effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_SQRTF
extern int FMP_SQRTF_f(int);
#pragma intrinsic(FMP_SQRTF_f,opcode=>7,sub_opcode=>32, set_flags => 1, flags => "zncv", effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_SQRTF15
extern int FMP_SQRTF15(int);
#pragma intrinsic(FMP_SQRTF15,opcode=>7,sub_opcode=>33, effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_SQRTF15
extern int FMP_SQRTF15_f(int);
#pragma intrinsic(FMP_SQRTF15_f,opcode=>7,sub_opcode=>33, set_flags => 1, flags => "zncv", effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_RNDH
extern int FMP_RNDH(int);
#pragma intrinsic(FMP_RNDH,opcode=>7,sub_opcode=>41, effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_RNDH
extern int FMP_RNDH_f(int);
#pragma intrinsic(FMP_RNDH_f,opcode=>7,sub_opcode=>41, set_flags => 1, flags => "zncv", effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_SATH
extern int FMP_SATH(int);
#pragma intrinsic(FMP_SATH,opcode=>7,sub_opcode=>40, effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_SATH
extern int FMP_SATH_f(int);
#pragma intrinsic(FMP_SATH_f,opcode=>7,sub_opcode=>40, set_flags => 1, flags => "zncv", effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_COS
extern int FMP_COS(int);
#pragma intrinsic(FMP_COS,opcode=>7,sub_opcode=>30, effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_COS
extern int FMP_COS_f(int);
#pragma intrinsic(FMP_COS_f,opcode=>7,sub_opcode=>30, set_flags => 1, flags => "zncv", effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_COS15
extern int FMP_COS15(int);
#pragma intrinsic(FMP_COS15,opcode=>7,sub_opcode=>44, effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_COS15
extern int FMP_COS15_f(int);
#pragma intrinsic(FMP_COS15_f,opcode=>7,sub_opcode=>44, set_flags => 1, flags => "zncv", effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_SIN
extern int FMP_SIN(int);
#pragma intrinsic(FMP_SIN,opcode=>7,sub_opcode=>31, effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_SIN
extern int FMP_SIN_f(int);
#pragma intrinsic(FMP_SIN_f,opcode=>7,sub_opcode=>31, set_flags => 1, flags => "zncv", effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_SIN15
extern int FMP_SIN15(int);
#pragma intrinsic(FMP_SIN15,opcode=>7,sub_opcode=>45, effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_SIN15
extern int FMP_SIN15_f(int);
#pragma intrinsic(FMP_SIN15_f,opcode=>7,sub_opcode=>45, set_flags => 1, flags => "zncv", effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_ATAN
extern int FMP_ATAN(int);
#pragma intrinsic(FMP_ATAN,opcode=>7,sub_opcode=>37, effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_ATAN
extern int FMP_ATAN_f(int);
#pragma intrinsic(FMP_ATAN_f,opcode=>7,sub_opcode=>37, set_flags => 1, flags => "zncv", effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_ATAN15
extern int FMP_ATAN15(int);
#pragma intrinsic(FMP_ATAN15,opcode=>7,sub_opcode=>46, effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_ATAN15
extern int FMP_ATAN15_f(int);
#pragma intrinsic(FMP_ATAN15_f,opcode=>7,sub_opcode=>46, set_flags => 1, flags => "zncv", effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_EXP2
extern int FMP_EXP2(int);
#pragma intrinsic(FMP_EXP2,opcode=>7,sub_opcode=>39, effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_EXP2
extern int FMP_EXP2_f(int);
#pragma intrinsic(FMP_EXP2_f,opcode=>7,sub_opcode=>39, set_flags => 1, flags => "zncv", effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_EXP215
extern int FMP_EXP215(int);
#pragma intrinsic(FMP_EXP215,opcode=>7,sub_opcode=>47, effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_EXP215
extern int FMP_EXP215_f(int);
#pragma intrinsic(FMP_EXP215_f,opcode=>7,sub_opcode=>47, set_flags => 1, flags => "zncv", effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_LOG2
extern int FMP_LOG2(int);
#pragma intrinsic(FMP_LOG2,opcode=>7,sub_opcode=>38, effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_LOG2
extern int FMP_LOG2_f(int);
#pragma intrinsic(FMP_LOG2_f,opcode=>7,sub_opcode=>38, set_flags => 1, flags => "zncv", effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_LOG215
extern int FMP_LOG215(int);
#pragma intrinsic(FMP_LOG215,opcode=>7,sub_opcode=>48, effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")

// User extension instruction FMP_LOG215
extern int FMP_LOG215_f(int);
#pragma intrinsic(FMP_LOG215_f,opcode=>7,sub_opcode=>48, set_flags => 1, flags => "zncv", effects=>"auxreg=0x470:is_read:is_written; auxreg=0xe8:is_read:is_written")


#endif


]]></string>
  </configuration>
  <configuration name="apex_assembly" filename="apexextensions.s">
    <string><![CDATA[

; Assembler directives for eia extensions in this design
.set apex_com_arc_hardware_fastmath_present,1
.set apex_com_arc_hardware_fastmath_present,1
.extAuxRegister FMP_CTRL,0x470,r|w
.extAuxRegister FMP_BUILD,0xe8,r
.extInstruction FMP_DIVF,7,32,SUFFIX_COND|SUFFIX_FLAG,SYNTAX_3OP
.extInstruction FMP_DIVF15,7,33,SUFFIX_COND|SUFFIX_FLAG,SYNTAX_3OP
.extInstruction FMP_ADDS,7,34,SUFFIX_COND|SUFFIX_FLAG,SYNTAX_3OP
.extInstruction FMP_RECIP,7,42,SUFFIX_FLAG,SYNTAX_2OP
.extInstruction FMP_RECIP15,7,43,SUFFIX_FLAG,SYNTAX_2OP
.extInstruction FMP_SQRTF,7,32,SUFFIX_FLAG,SYNTAX_2OP
.extInstruction FMP_SQRTF15,7,33,SUFFIX_FLAG,SYNTAX_2OP
.extInstruction FMP_RNDH,7,41,SUFFIX_FLAG,SYNTAX_2OP
.extInstruction FMP_SATH,7,40,SUFFIX_FLAG,SYNTAX_2OP
.extInstruction FMP_COS,7,30,SUFFIX_FLAG,SYNTAX_2OP
.extInstruction FMP_COS15,7,44,SUFFIX_FLAG,SYNTAX_2OP
.extInstruction FMP_SIN,7,31,SUFFIX_FLAG,SYNTAX_2OP
.extInstruction FMP_SIN15,7,45,SUFFIX_FLAG,SYNTAX_2OP
.extInstruction FMP_ATAN,7,37,SUFFIX_FLAG,SYNTAX_2OP
.extInstruction FMP_ATAN15,7,46,SUFFIX_FLAG,SYNTAX_2OP
.extInstruction FMP_EXP2,7,39,SUFFIX_FLAG,SYNTAX_2OP
.extInstruction FMP_EXP215,7,47,SUFFIX_FLAG,SYNTAX_2OP
.extInstruction FMP_LOG2,7,38,SUFFIX_FLAG,SYNTAX_2OP
.extInstruction FMP_LOG215,7,48,SUFFIX_FLAG,SYNTAX_2OP

]]></string>
  </configuration>
  <configuration name="system_memmap" filename="alb_mss_fab_system_memmap.h">
    <string><![CDATA[
/*************************************************************************/
/**                                                                     **/
/** Copyright (C) 2016-2017 Synopsys, Inc.                              **/
/** All Rights Reserved.                                                **/
/**                                                                     **/
/** This Synopsys software and all associated documentation are         **/
/** proprietary to Synopsys, Inc. and may only be used pursuant to the  **/
/** terms and conditions of a written license agreement with Synopsys,  **/
/** Inc. All other use, reproduction, modification, or distribution of  **/
/** this Synopsys software or the associated documentation is strictly  **/
/** prohibited.                                                         **/
/**                                                                     **/
/*************************************************************************/


/* **** DO NOT EDIT - this file is generated by ARChitect2 ****
 *
 * Description: Header file declaring the compiler extensions for System Memory
 */
#ifndef  _alb_mss_fab_system_memmap_H_
#define  _alb_mss_fab_system_memmap_H_
// System memory map
#define SCCM_AXI_0_BASE 0x40000000
#define SCCM_AXI_0_SIZE 0x1000000
#define SCCM_AXI_1_BASE 0x41000000
#define SCCM_AXI_1_SIZE 0x1000000
#define SCCM_AXI_2_BASE 0x42000000
#define SCCM_AXI_2_SIZE 0x1000000
#define SCCM_AXI_3_BASE 0x43000000
#define SCCM_AXI_3_SIZE 0x1000000
#define SCCM_AXI_4_BASE 0x44000000
#define SCCM_AXI_4_SIZE 0x1000000
#define SCCM_AXI_5_BASE 0x45000000
#define SCCM_AXI_5_SIZE 0x1000000
#define SCCM_AXI_6_BASE 0x46000000
#define SCCM_AXI_6_SIZE 0x1000000
#define SCCM_AXI_7_BASE 0x47000000
#define SCCM_AXI_7_SIZE 0x1000000
#define SCCM_AXI_8_BASE 0x48000000
#define SCCM_AXI_8_SIZE 0x1000000
#define SCCM_AXI_9_BASE 0x49000000
#define SCCM_AXI_9_SIZE 0x1000000
#define SCCM_AXI_10_BASE 0x4a000000
#define SCCM_AXI_10_SIZE 0x1000000
#define SCCM_AXI_11_BASE 0x4b000000
#define SCCM_AXI_11_SIZE 0x1000000
#define CSM_DMI_EMPTY_0_BASE 0x4c000000
#define CSM_DMI_EMPTY_0_SIZE 0x40000
#define MSS_CLKCTRL_0_BASE 0xc0000000
#define MSS_CLKCTRL_0_SIZE 0x1000
#define MSS_SNOOP_TRAFGEN_SLV_0_BASE 0xc0002000
#define MSS_SNOOP_TRAFGEN_SLV_0_SIZE 0x1000
#define MSS_MEM_0_BASE 0x0000
#define MSS_MEM_0_SIZE 0x100000000

// CCM system address with the specific name
#define c0ICCM0_SYS_BASE 0x40000000
#define c0ICCM0_SYS_SIZE 0x1000000
#define c0ICCM1_SYS_BASE 0x41000000
#define c0ICCM1_SYS_SIZE 0x1000000
#define c0DCCM_SYS_BASE 0x42000000
#define c0DCCM_SYS_SIZE 0x1000000
#define c1ICCM0_SYS_BASE 0x43000000
#define c1ICCM0_SYS_SIZE 0x1000000
#define c1ICCM1_SYS_BASE 0x44000000
#define c1ICCM1_SYS_SIZE 0x1000000
#define c1DCCM_SYS_BASE 0x45000000
#define c1DCCM_SYS_SIZE 0x1000000
#define c2ICCM0_SYS_BASE 0x46000000
#define c2ICCM0_SYS_SIZE 0x1000000
#define c2ICCM1_SYS_BASE 0x47000000
#define c2ICCM1_SYS_SIZE 0x1000000
#define c2DCCM_SYS_BASE 0x48000000
#define c2DCCM_SYS_SIZE 0x1000000
#define c3ICCM0_SYS_BASE 0x49000000
#define c3ICCM0_SYS_SIZE 0x1000000
#define c3ICCM1_SYS_BASE 0x4a000000
#define c3ICCM1_SYS_SIZE 0x1000000
#define c3DCCM_SYS_BASE 0x4b000000
#define c3DCCM_SYS_SIZE 0x1000000

#define HAS_DEFAULT_SLAVE 1
#endif
]]></string>
  </configuration>
</config_list>

